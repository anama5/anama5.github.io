<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我未成名君未嫁 可能俱是不如人">
<meta property="og:type" content="website">
<meta property="og:title" content="琅嬛福地">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="琅嬛福地">
<meta property="og:description" content="我未成名君未嫁 可能俱是不如人">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="安₃">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>琅嬛福地</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

<a target="_blank" rel="noopener" href="https://github.com/anama5" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">琅嬛福地</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/08-DOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/08-DOM/" class="post-title-link" itemprop="url">08-DOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-14 19:57:59 / 修改时间：20:04:31" itemprop="dateCreated datePublished" datetime="2022-02-14T19:57:59+08:00">2022-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-DOM-架构"><a href="#一-DOM-架构" class="headerlink" title="一 DOM 架构"></a>一 DOM 架构</h1><p><img src="D:\唯手熟尔\02-CS\03-招式\01-前端\03-JavaScript\img\DOM架构.png"></p>
<ol>
<li> 浏览器是用来展示网页的，而网页中最重要的就是里面各种的标签元素，JavaScript 很多时候是需要操作这些元素</li>
<li> DOM <code>Document Object Model</code> 文档对象模型</li>
<li> DOM 提供了一系列的模型和对象，可以很方便的操作页面</li>
</ol>
<h1 id="二-EventTarget"><a href="#二-EventTarget" class="headerlink" title="二 EventTarget"></a>二 EventTarget</h1><h2 id="2-1-方法"><a href="#2-1-方法" class="headerlink" title="2.1 方法"></a>2.1 方法</h2><h3 id="1-addEventListener"><a href="#1-addEventListener" class="headerlink" title="1 addEventListener"></a>1 addEventListener</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(type, listener);</span><br><span class="line">addEventListener(type, listener, options);</span><br><span class="line">addEventListener(type, listener, useCapture);</span><br></pre></td></tr></table></figure>

<ol>
<li>添加事件监听</li>
<li>参数<ol>
<li>type：事件类型字符串，大小写敏感，如 click focus …</li>
<li>listener：监听函数</li>
<li>useCapture：<ul>
<li>false：默认，冒泡阶段触发</li>
<li>true：捕获阶段触发</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-removeEventListener"><a href="#2-removeEventListener" class="headerlink" title="2 removeEventListener"></a>2 removeEventListener</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">removeEventListener(type, listener);</span><br><span class="line">removeEventListener(type, listener, options);</span><br><span class="line">removeEventListener(type, listener, useCapture);</span><br></pre></td></tr></table></figure>

<h3 id="3-dispatchEvent"><a href="#3-dispatchEvent" class="headerlink" title="3 dispatchEvent"></a>3 dispatchEvent</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatchEvent(event)</span><br></pre></td></tr></table></figure>

<ol>
<li>派发某个事件类型到 EventTarget 上</li>
<li>参数<ul>
<li>event：The Event object to dispatch. Its <code>Event.target</code> property will be set to the current  EventTarget</li>
</ul>
</li>
</ol>
<h2 id="2-2-其它说明"><a href="#2-2-其它说明" class="headerlink" title="2.2 其它说明"></a>2.2 其它说明</h2><h3 id="1-NodeList"><a href="#1-NodeList" class="headerlink" title="1 NodeList"></a>1 NodeList</h3><ol>
<li><p><code>NodeList</code> 是节点的集合，是类数组对象</p>
<ol>
<li><code>Node.childNodes</code> 返回的是一个动态集合，即文档中的节点树发生变化，<code>NodeList</code> 也会随之变化</li>
<li>其他的 <code>NodeList</code> 都是静态集合</li>
</ol>
</li>
<li><p><code>NodeList</code> 的 <code>length</code> 属性表示其包含的节点数量</p>
</li>
<li><p><code>NodeList</code> 的遍历（类数组对象，有索引）</p>
<ol>
<li><code>for</code> 循环</li>
<li><code>forEach()</code></li>
<li><code>keys()</code></li>
<li><code>values()</code></li>
<li><code>entries()</code></li>
</ol>
</li>
</ol>
<h3 id="2-HTMLCollection"><a href="#2-HTMLCollection" class="headerlink" title="2 HTMLCollection"></a>2 HTMLCollection</h3><ol>
<li><code>HTMLCollection</code> 元素节点的集合，是类数组对象</li>
<li><code>HTMLCollection</code> 都是动态集合</li>
<li><code>HTMLCollection</code> 的 <code>length</code> 属性表示其包含的节点数量</li>
<li><code>HTMLCollection</code> 不能使用 <code>foreach</code> 遍历</li>
</ol>
<h1 id="三-Node"><a href="#三-Node" class="headerlink" title="三 Node"></a>三 Node</h1><h2 id="3-1-分类"><a href="#3-1-分类" class="headerlink" title="3.1 分类"></a>3.1 分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th align="center">nodeType</th>
<th>nodeName</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td><code>Element</code></td>
<td>元素节点</td>
<td>页面 HTML 标签</td>
<td align="center"><code>1</code></td>
<td>大写的标签名</td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>Attr</code></td>
<td>属性节点</td>
<td>页面标签的属性</td>
<td align="center"><code>2</code></td>
<td>属性名</td>
<td>属性值</td>
</tr>
<tr>
<td><code>Text</code></td>
<td>文本节点</td>
<td>页面中的文本</td>
<td align="center"><code>3</code></td>
<td><code>#text</code></td>
<td>文本内容</td>
</tr>
<tr>
<td><code>Comment</code></td>
<td>注释节点</td>
<td>注释</td>
<td align="center"><code>8</code></td>
<td><code>#comment</code></td>
<td>注释内容</td>
</tr>
<tr>
<td><code>Document</code></td>
<td>文档节点</td>
<td>整个页面</td>
<td align="center"><code>9</code></td>
<td><code>#document</code></td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>DocumentType</code></td>
<td>文档类型节点</td>
<td><code>&lt;!DOCTYPE html&gt;</code></td>
<td align="center"><code>10</code></td>
<td>文档的类型</td>
<td><code>null</code></td>
</tr>
<tr>
<td><code>DocumentFragment</code></td>
<td>文档片段节点</td>
<td>一个没有父级文件的最小文档对象</td>
<td align="center"><code>11</code></td>
<td><code>#document-fragment</code></td>
<td><code>null</code></td>
</tr>
</tbody></table>
<h2 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h2><h3 id="1-节点信息"><a href="#1-节点信息" class="headerlink" title="1 节点信息"></a>1 节点信息</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>nodeType</code></td>
<td>读</td>
<td>节点类型（整数值）</td>
</tr>
<tr>
<td><code>nodeName</code></td>
<td>读</td>
<td>节点名</td>
</tr>
<tr>
<td><code>nodeValue</code></td>
<td>读写</td>
<td>获取或设置当前节点的值</td>
</tr>
<tr>
<td><code>baseURI</code></td>
<td>读</td>
<td>当前网页的绝对路径 URI</td>
</tr>
</tbody></table>
<h3 id="2-节点结构"><a href="#2-节点结构" class="headerlink" title="2 节点结构"></a>2 节点结构</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>childNodes</code></td>
<td>读</td>
<td>所有子节点的 <code>NodeList</code> 集合</td>
</tr>
<tr>
<td><code>parentNode</code></td>
<td>读</td>
<td>父节点</td>
</tr>
<tr>
<td><code>firstChild</code></td>
<td>读</td>
<td>第一个子节点</td>
</tr>
<tr>
<td><code>lastChild</code></td>
<td>读</td>
<td>最后一个子节点</td>
</tr>
<tr>
<td><code>nextSibling</code></td>
<td>读</td>
<td>弟节点</td>
</tr>
<tr>
<td><code>previousSibling</code></td>
<td>读</td>
<td>兄节点</td>
</tr>
</tbody></table>
<h3 id="3-元素节点结构"><a href="#3-元素节点结构" class="headerlink" title="3 元素节点结构"></a>3 元素节点结构</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>parentElement</code></td>
<td>读</td>
<td>父元素节点，若没有父节点或父节点不是元素节点则返回 <code>null</code></td>
</tr>
<tr>
<td><code>children</code></td>
<td>读</td>
<td>所有子元素节点，非标准，但推荐使用</td>
</tr>
<tr>
<td><code>firstElementChild</code></td>
<td>读</td>
<td>第一个子元素节点，有兼容问题，推荐 <code>children[0]</code></td>
</tr>
<tr>
<td><code>lastElementChild</code></td>
<td>读</td>
<td>最后一个子元素节点，有兼容问题，推荐 <code>children[children.length-1]</code></td>
</tr>
<tr>
<td><code>nextElementSibling</code></td>
<td>读</td>
<td>弟元素节点，有兼容问题</td>
</tr>
<tr>
<td><code>previousElementSibling</code></td>
<td>读</td>
<td>兄元素节点，有兼容问题</td>
</tr>
</tbody></table>
<h2 id="3-3-方法"><a href="#3-3-方法" class="headerlink" title="3.3 方法"></a>3.3 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>parentNode.appendChild(childNode)</code></td>
<td>追加子节点</td>
</tr>
<tr>
<td><code>parentNode.removeChild(childNode)</code></td>
<td>删除子节点</td>
</tr>
<tr>
<td><code>parentNode.replaceChild(newNode, oldNode)</code></td>
<td>替换子节点</td>
</tr>
<tr>
<td><code>parentNode.insertBefore(childNode, targetNode)</code></td>
<td>将子节点插入到目标节点之前</td>
</tr>
<tr>
<td><code>node.cloneNode([flag])</code></td>
<td>克隆节点，无参或 <code>false</code> 为浅拷贝，<code>true</code> 为深拷贝</td>
</tr>
<tr>
<td><code>node.hasChildNodes()</code></td>
<td>判断是否有子节点</td>
</tr>
<tr>
<td><code>node.contains(node)</code></td>
<td>判断是否是其自己或后代节点</td>
</tr>
</tbody></table>
<h1 id="四-Document"><a href="#四-Document" class="headerlink" title="四 Document"></a>四 Document</h1><h2 id="4-1-属性"><a href="#4-1-属性" class="headerlink" title="4.1 属性"></a>4.1 属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>documentElement</td>
<td>获取 <code>&lt;html&gt;</code> 元素节点</td>
</tr>
<tr>
<td>head</td>
<td>获取 <code>&lt;head&gt;</code> 元素节点</td>
</tr>
<tr>
<td>body</td>
<td>获取 <code>&lt;body&gt;</code> 元素节点</td>
</tr>
<tr>
<td>children</td>
<td>获取当前文档的子元素，通常返回只包含 <code>&lt;html&gt;</code> 元素的 <code>HTMLCollection</code></td>
</tr>
<tr>
<td>location</td>
<td>浏览器地址栏对象</td>
</tr>
<tr>
<td>forms</td>
<td>返回所有 <code>&lt;form&gt;</code> 表单节点的  <code>HTMLCollection</code></td>
</tr>
</tbody></table>
<h2 id="4-2-方法"><a href="#4-2-方法" class="headerlink" title="4.2 方法"></a>4.2 方法</h2><h3 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getElementById(id)</code></td>
<td>根据元素 ID 获取 <code>Element</code> 对象</td>
</tr>
<tr>
<td><code>getElementsByTagName(tagName)</code></td>
<td>根据标签名获取元素节点的 <code>HTMLCollection</code> 集合</td>
</tr>
<tr>
<td><code>getElementsByClassName(class)</code></td>
<td>根据 <code>class</code> 属性值获取元素节点的 <code>HTMLCollection</code> 集合</td>
</tr>
<tr>
<td><code>getElementsByName(name)</code></td>
<td>根据元素 <code>name</code> 属性的值获取节点的 <code>NodeList</code> 集合</td>
</tr>
<tr>
<td><code>querySelector(selector)</code></td>
<td>返回第一个匹配的节点</td>
</tr>
<tr>
<td><code>querySelectorAll(selector)</code></td>
<td>返回所有匹配节点的 <code>NodeList</code> 集合</td>
</tr>
</tbody></table>
<h3 id="2-创建"><a href="#2-创建" class="headerlink" title="2 创建"></a>2 创建</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>createElement(tageName)</code></td>
<td>创建元素节点</td>
</tr>
<tr>
<td><code>createAttribute(attrName)</code></td>
<td>创建属性节点</td>
</tr>
<tr>
<td><code>createTextNode(text)</code></td>
<td>创建文本节点</td>
</tr>
<tr>
<td><code>createComment(comment)</code></td>
<td>创建注释节点</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* 创建节点的方式</span><br><span class="line">// 1 </span><br><span class="line">let imgElement = document.createElement(&quot;img&quot;);</span><br><span class="line">// 等价于</span><br><span class="line">let imgElemetn = new HTMLImageElement();</span><br><span class="line"></span><br><span class="line">// 2 直接将内容写入页面，如果文档流加载完毕才执行，会导致页面重绘（仍掉原页面，创建新页面且只有写出的内容）</span><br><span class="line">document.write()</span><br><span class="line"></span><br><span class="line">// 3 innerHTML</span><br><span class="line">* 创建多个元素通过拼接字符串创建，效率底</span><br><span class="line">* 创建多个元素通过数组形式拼接，效率高，但复杂</span><br></pre></td></tr></table></figure>

<h1 id="五-Element"><a href="#五-Element" class="headerlink" title="五 Element"></a>五 Element</h1><h2 id="5-1-属性"><a href="#5-1-属性" class="headerlink" title="5.1 属性"></a>5.1 属性</h2><h3 id="1-信息属性"><a href="#1-信息属性" class="headerlink" title="1 信息属性"></a>1 信息属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>读写</td>
<td>元素 id</td>
</tr>
<tr>
<td>tagName</td>
<td>读</td>
<td>元素标签名</td>
</tr>
<tr>
<td>className</td>
<td>读写</td>
<td>返回 class 属性的字符串，多个用空格分隔</td>
</tr>
<tr>
<td>classList</td>
<td>读</td>
<td>返回 class 属性的类数组对象</td>
</tr>
<tr>
<td>innerHTML</td>
<td>读写</td>
<td>识别 Html 标签，保留 Html 标签、空格和换行，w3c 标准</td>
</tr>
<tr>
<td>innerText</td>
<td>读写</td>
<td>不识别 Html 标签，会去除 Html标签以及空格和换行，非标准</td>
</tr>
<tr>
<td>dataset</td>
<td>读</td>
<td>存放了所有以 <code>data-</code> 开头的自定义属性的集合</td>
</tr>
<tr>
<td>hiddent</td>
<td>读写</td>
<td>元素是否隐藏</td>
</tr>
<tr>
<td>style</td>
<td>读写</td>
<td>元素的行内样式信息，带单位</td>
</tr>
</tbody></table>
<h3 id="2-offset-系列属性"><a href="#2-offset-系列属性" class="headerlink" title="2 offset 系列属性"></a>2 offset 系列属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>offsetParent</td>
<td>读</td>
<td>返回该元素带有定位的祖先元素，如果没有则返回 <code>body</code></td>
</tr>
<tr>
<td>offsetTop</td>
<td>读</td>
<td>返回元素相对定位祖先元素上方的偏移量，不带单位</td>
</tr>
<tr>
<td>offsetLeft</td>
<td>读</td>
<td>返回元素相对定位祖先元素左方的偏移量，不带单位</td>
</tr>
<tr>
<td>offsetWidth</td>
<td>读</td>
<td>返回 <code>boder-box</code> 的宽度，不带单位</td>
</tr>
<tr>
<td>offsetHeight</td>
<td>读</td>
<td>返回 <code>boder-box</code> 的高度，不带单位</td>
</tr>
</tbody></table>
<h4 id="offset-amp-style-的区别"><a href="#offset-amp-style-的区别" class="headerlink" title="offset &amp; style 的区别"></a>offset &amp; style 的区别</h4><table>
<thead>
<tr>
<th><code>offset</code></th>
<th><code>style</code></th>
</tr>
</thead>
<tbody><tr>
<td>获取任意样式表的值</td>
<td>获取行内样式表的值</td>
</tr>
<tr>
<td>获取的值没有单位</td>
<td>获取的值有单位</td>
</tr>
<tr>
<td><code>offsetWidth = width + padding + border</code></td>
<td><code>style.width = width</code></td>
</tr>
<tr>
<td>只读</td>
<td>读写</td>
</tr>
</tbody></table>
<h3 id="3-client-系列属性"><a href="#3-client-系列属性" class="headerlink" title="3 client 系列属性"></a>3 client 系列属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clientTop</td>
<td>读</td>
<td>元素上边框大小</td>
</tr>
<tr>
<td>clientLeft</td>
<td>读</td>
<td>元素左边框大小</td>
</tr>
<tr>
<td>clientWidth</td>
<td>读</td>
<td><code>padding-box</code> 的可视宽度，不带单位</td>
</tr>
<tr>
<td>clientHeight</td>
<td>读</td>
<td><code>padding-box</code> 的可视高度，不带单位</td>
</tr>
</tbody></table>
<h3 id="4-scroll-系列属性"><a href="#4-scroll-系列属性" class="headerlink" title="4 scroll 系列属性"></a>4 scroll 系列属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scrollLeft</td>
<td>读</td>
<td>被卷去的上侧距离，不带单位</td>
</tr>
<tr>
<td>scrollTop</td>
<td>读</td>
<td>被卷去的左侧距离，不带单位</td>
</tr>
<tr>
<td>scrollWidth</td>
<td>读</td>
<td><code>padding-box</code> 的实际宽度，不带单位</td>
</tr>
<tr>
<td>scrollHeight</td>
<td>读</td>
<td><code>padding-box</code> 的实际高度，不带单位</td>
</tr>
</tbody></table>
<h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getAttribute(key)</code></td>
<td>获取属性的值</td>
</tr>
<tr>
<td><code>setAttribute(key, value)</code></td>
<td>设置属性的值</td>
</tr>
<tr>
<td><code>removeAttribute(key)</code></td>
<td>删除属性</td>
</tr>
<tr>
<td><code>getAttributeNames()</code></td>
<td>返回当前元素所有属性名</td>
</tr>
<tr>
<td><code>hasAttribute(key)</code></td>
<td>当前元素是否有某个属性</td>
</tr>
<tr>
<td><code>hasAttributes()</code></td>
<td>当前元素是否有属性</td>
</tr>
<tr>
<td><code>click() </code></td>
<td>模拟鼠标左键单击一个元素</td>
</tr>
</tbody></table>
<ul>
<li><code>Document</code> 中用来获取元素节点的方法，<code>Element</code> 也能用，只是匹配范围是当前元素而非整个文档</li>
</ul>
<h1 id="六-事件监听"><a href="#六-事件监听" class="headerlink" title="六 事件监听"></a>六 事件监听</h1><h2 id="6-1-事件监听的注册方式"><a href="#6-1-事件监听的注册方式" class="headerlink" title="6.1 事件监听的注册方式"></a>6.1 事件监听的注册方式</h2><ol>
<li><p>在 script 中直接监听（不推荐）</p>
</li>
<li><p>通过元素的 on 来监听事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 绑定事件</span><br><span class="line">element.onEventType = function()&#123;&#125; </span><br><span class="line"># 解绑事件</span><br><span class="line">element.onclick=null;</span><br></pre></td></tr></table></figure>

<pre><code>    1. 只在冒泡阶段触发
    1. 同一个元素同一个事件只能定义一个监听函数，多次定义会覆盖
</code></pre>
</li>
<li><p>使用 EventTarget 中的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 绑定事件</span><br><span class="line">addEventListener(type, listener[, useCapture]) </span><br><span class="line">// 解绑事件</span><br><span class="line">removeEventListener(type, listener[, useCapture]) </span><br></pre></td></tr></table></figure>

<ol>
<li>同一个元素同一个事件可以添加多个监听函数</li>
<li>能够指定在哪个阶段（捕获阶段 or 冒泡阶段）触发监听函数</li>
</ol>
</li>
</ol>
<h2 id="6-2-事件流"><a href="#6-2-事件流" class="headerlink" title="6.2 事件流"></a>6.2 事件流</h2><p><img src="D:\唯手熟尔\02-CS\03-招式\01-前端\03-JavaScript\img\事件流.png"></p>
<ol>
<li>事件流描述的是从页面中接收事件的顺序</li>
<li>事件发生时会在元素节点之间按照特定的顺序传播，此传播过程即 DOM 事件流</li>
<li>JS 代码中只能执行捕获或者冒泡中的一个阶段</li>
<li>事件委托<ul>
<li>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件</li>
<li>优点：只操作一次DOM，性能更高</li>
</ul>
</li>
</ol>
<h2 id="6-3-Event"><a href="#6-3-Event" class="headerlink" title="6.3 Event"></a>6.3 Event</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>事件发生以后，系统会自动创建一个事件对象 <code>Event</code>，作为参数传给监听函数</li>
<li>事件对象包含了一系列与事件相关的信息</li>
<li><code>Event</code> 有许多子类，如 <code>MouseEvent, KeyboardEvent, TouchEvent...</code> </li>
</ol>
<h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2 属性"></a>2 属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>触发事件的元素（可能并非是当前元素）</td>
</tr>
<tr>
<td>currentTarget</td>
<td>当前元素</td>
</tr>
<tr>
<td>type</td>
<td>事件类型（名称）</td>
</tr>
</tbody></table>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>preventDefault()</code></td>
<td>取消事件的默认行为（如跳转，提交…）</td>
</tr>
<tr>
<td><code>stopPropagation()</code></td>
<td>阻止事件传播（捕获/冒泡）</td>
</tr>
</tbody></table>
<h2 id="6-4-鼠标"><a href="#6-4-鼠标" class="headerlink" title="6.4 鼠标"></a>6.4 鼠标</h2><h3 id="1-事件"><a href="#1-事件" class="headerlink" title="1 事件"></a>1 事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>click</code></td>
<td>单击</td>
</tr>
<tr>
<td><code>dblclick</code></td>
<td>双击</td>
</tr>
<tr>
<td><code>focus</code></td>
<td>获取焦点，该事件不会冒泡</td>
</tr>
<tr>
<td><code>blur</code></td>
<td>失去焦点，该事件不会冒泡</td>
</tr>
<tr>
<td><code>mousedown</code></td>
<td>鼠标键按下</td>
</tr>
<tr>
<td><code>mouseup</code></td>
<td>鼠标键弹起</td>
</tr>
<tr>
<td><code>mousemove</code></td>
<td>鼠标移动</td>
</tr>
<tr>
<td><code>mouseenter</code></td>
<td>鼠标经过，该事件不会冒泡</td>
</tr>
<tr>
<td><code>mouseleave</code></td>
<td>鼠标离开，该事件不会冒泡</td>
</tr>
<tr>
<td><code>mouseover</code></td>
<td>鼠标经过</td>
</tr>
<tr>
<td><code>mouseout</code></td>
<td>鼠标离开</td>
</tr>
<tr>
<td><code>contextmenu</code></td>
<td>右键菜单，常使用 <code>event.preventDefault()</code> 来禁止右键菜单</td>
</tr>
<tr>
<td><code>selectstart</code></td>
<td>选中文字，常使用 <code>event.preventDefault()</code> 来禁止选中文字</td>
</tr>
</tbody></table>
<h3 id="2-MouseEvent"><a href="#2-MouseEvent" class="headerlink" title="2 MouseEvent"></a>2 MouseEvent</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>clientX</code></td>
<td>鼠标相对于浏览器窗口可视区的 X 坐标</td>
</tr>
<tr>
<td><code>clientY</code></td>
<td>鼠标相对于浏览器窗口可视区的 Y 坐标</td>
</tr>
<tr>
<td><code>pageX</code></td>
<td>鼠标相对于文档页面的 X 坐标</td>
</tr>
<tr>
<td><code>pageY</code></td>
<td>鼠标相对于文档页面的 Y 坐标</td>
</tr>
<tr>
<td><code>screenX</code></td>
<td>鼠标相对于电脑屏幕的 X 坐标</td>
</tr>
<tr>
<td><code>screenY</code></td>
<td>鼠标相对于电脑屏幕的 Y 坐标</td>
</tr>
</tbody></table>
<h2 id="6-5-键盘"><a href="#6-5-键盘" class="headerlink" title="6.5 键盘"></a>6.5 键盘</h2><h3 id="1-事件-1"><a href="#1-事件-1" class="headerlink" title="1 事件"></a>1 事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>keydown</code></td>
<td>按下键盘按键之后文字未输入之前触发，顺序在 <code>keypress</code> 之前，不区分大小写</td>
</tr>
<tr>
<td><code>keypress</code></td>
<td>按下有值的键之后文字未输入之前触发触发，区分大小写，不识别功能键如 <code>→ ← ctrl alt shift...</code></td>
</tr>
<tr>
<td><code>keyup</code></td>
<td>弹起键盘按键触发，不区分大小写</td>
</tr>
</tbody></table>
<h3 id="2-KeyboardEvent"><a href="#2-KeyboardEvent" class="headerlink" title="2 KeyboardEvent"></a>2 KeyboardEvent</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>keyCode</code></td>
<td>按键对应的 ASCII 码值</td>
</tr>
</tbody></table>
<h2 id="6-6-触屏"><a href="#6-6-触屏" class="headerlink" title="6.6 触屏"></a>6.6 触屏</h2><h3 id="1-事件-2"><a href="#1-事件-2" class="headerlink" title="1 事件"></a>1 事件</h3><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>touchstart</code></td>
<td>触摸到一个 DOM 元素时触发</td>
</tr>
<tr>
<td><code>touchmove</code></td>
<td>在一个 DOM 元素上滑动时触发</td>
</tr>
<tr>
<td><code>touchend</code></td>
<td>从一个 DOM 元素上移开时触发</td>
</tr>
</tbody></table>
<h3 id="2-概念"><a href="#2-概念" class="headerlink" title="2 概念"></a>2 概念</h3><table>
<thead>
<tr>
<th>对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Touch</code></td>
<td>单个触摸点。触摸点可能是一根手指，也可能是一根触摸笔</td>
</tr>
<tr>
<td><code>TouchList</code></td>
<td>多个触摸点的集合</td>
</tr>
<tr>
<td><code>TouchEvent</code></td>
<td>触摸引发的事件实例</td>
</tr>
</tbody></table>
<h3 id="3-TouchEvent"><a href="#3-TouchEvent" class="headerlink" title="3 TouchEvent"></a>3 TouchEvent</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>touches</code></td>
<td><code>TouchList</code>，正在触摸屏幕的触点的列表</td>
</tr>
<tr>
<td><code>targetTouches</code></td>
<td><code>TouchList</code>，正在触摸当前 DOM 元素的触点的列表</td>
</tr>
<tr>
<td><code>changedTouches</code></td>
<td><code>TouchList</code>，状态发生改变的触点的列表</td>
</tr>
</tbody></table>
<h3 id="4-TouchList"><a href="#4-TouchList" class="headerlink" title="4 TouchList"></a>4 TouchList</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>节点数量</td>
</tr>
<tr>
<td><code>item(index)</code></td>
<td>获取指定索引的节点，可以用 <code>list[index]</code> 代替</td>
</tr>
</tbody></table>
<h3 id="5-Touch"><a href="#5-Touch" class="headerlink" title="5 Touch"></a>5 Touch</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>identifier</code></td>
<td>返回一个整数，表示触摸点的唯一 ID</td>
</tr>
<tr>
<td><code>target</code></td>
<td>触摸的节点</td>
</tr>
<tr>
<td><code>clientX</code></td>
<td>触点相对于可见视区左边沿的的 X 坐标</td>
</tr>
<tr>
<td><code>clientY</code></td>
<td>触点相对于可见视区上边沿的的 Y 坐标.</td>
</tr>
<tr>
<td><code>pageX</code></td>
<td>触点相对于 HTML 文档左边沿的的 X 坐标</td>
</tr>
<tr>
<td><code>pageY</code></td>
<td>触点相对于 HTML 文档上边沿的的 Y 坐标</td>
</tr>
<tr>
<td><code>screenX</code></td>
<td>触点相对于屏幕左边沿的的 X 坐标</td>
</tr>
<tr>
<td><code>screenY</code></td>
<td>触点相对于屏幕上边沿的的 Y 坐标</td>
</tr>
</tbody></table>
<h2 id="6-7-表单"><a href="#6-7-表单" class="headerlink" title="6.7 表单"></a>6.7 表单</h2><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>input</code></td>
<td>当 <code>&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;</code> 的值发生变化时触发</td>
</tr>
<tr>
<td><code>change</code></td>
<td>同 <code>input</code> 区别是如果有连续变化，<code>input</code> 事件会触发多次，而 <code>change</code> 事件只在失去焦点时触发一次</td>
</tr>
<tr>
<td><code>select</code></td>
<td>在<code>&lt;input&gt;、&lt;textarea&gt;</code> 里面选中文本时触发</td>
</tr>
<tr>
<td><code>invalid</code></td>
<td>提交表单时，如果表单元素的值不满足校验条件时触发</td>
</tr>
<tr>
<td><code>reset</code></td>
<td>重置表单时触发</td>
</tr>
<tr>
<td><code>submit</code></td>
<td>提交表单时触发</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/07-BOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/07-BOM/" class="post-title-link" itemprop="url">07-BOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-14 19:57:51 / 修改时间：19:59:42" itemprop="dateCreated datePublished" datetime="2022-02-14T19:57:51+08:00">2022-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><ol>
<li>JavaScript 有一个非常重要的运行环境就是浏览器，而且浏览器本身又作为一个应用程序需要对其本身进行操作，所以通常浏览器会有对应的对象模型（BOM，Browser Object Model）</li>
<li>BOM 可以看作连接 JavaScript 脚本与浏览器窗口的桥梁</li>
<li>BOM 由浏览器厂商各自定义，兼容性较差</li>
<li>BOM 包含 DOM</li>
<li>BOM 主要包括一下的对象模型<ol>
<li>window：包括全局属性、方法，控制浏览器窗口相关的属性、方法</li>
<li>location：浏览器连接到的对象的位置（URL）</li>
<li>history：操作浏览器的历史</li>
<li>document：当前窗口操作文档的对象</li>
</ol>
</li>
</ol>
<h1 id="二-window"><a href="#二-window" class="headerlink" title="二 window"></a>二 window</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>window 对象在浏览器中有两个身份<ol>
<li>全局对象：ECMAScript 有一个全局对象的，这个全局对象在Node中是 global，在浏览器中就是 window 对象</li>
<li>浏览器窗口对象：提供了对浏览器操作的相关的API</li>
</ol>
</li>
<li>window 中包含了大量的属性、方法、事件…</li>
</ol>
<h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td>窗口名</td>
</tr>
<tr>
<td><code>innerWidth</code></td>
<td>窗口可视宽度（不包括菜单栏侧边栏…）</td>
</tr>
<tr>
<td><code>innerHeight</code></td>
<td>窗口可视高度</td>
</tr>
<tr>
<td><code>screenX</code></td>
<td>窗口距离屏幕左侧距离</td>
</tr>
<tr>
<td><code>screenY</code></td>
<td>窗口距离屏幕顶侧距离</td>
</tr>
<tr>
<td><code>pageXOffset</code></td>
<td>页面的水平滚动距离</td>
</tr>
<tr>
<td><code>pageYOffset</code></td>
<td>页面的垂直滚动距离</td>
</tr>
<tr>
<td><code>document</code></td>
<td>返回 Document 对象</td>
</tr>
<tr>
<td><code>location</code></td>
<td>返回 Location 对象</td>
</tr>
<tr>
<td><code>navigator</code></td>
<td>返回 Navigator 对象</td>
</tr>
<tr>
<td><code>history</code></td>
<td>返回 History 对象</td>
</tr>
<tr>
<td><code>console</code></td>
<td>返回 Console 对象</td>
</tr>
<tr>
<td><code>screen</code></td>
<td>返回 Screen 对象</td>
</tr>
<tr>
<td><code>localStorage</code></td>
<td>返回 <code>localStorage</code> 对象</td>
</tr>
<tr>
<td><code>sessionStorage</code></td>
<td>返回 <code>sessionStorage</code> 对象</td>
</tr>
</tbody></table>
<h2 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a>2.3 方法</h2><h3 id="1-弹窗"><a href="#1-弹窗" class="headerlink" title="1 弹窗"></a>1 弹窗</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>alert(message)</code></td>
<td>提示框</td>
</tr>
<tr>
<td><code>confirm(message)</code></td>
<td>确认框</td>
</tr>
<tr>
<td><code>prompt([message,] value)</code></td>
<td>输入框</td>
</tr>
</tbody></table>
<h3 id="2-定时器"><a href="#2-定时器" class="headerlink" title="2 定时器"></a>2 定时器</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>setTimeout(function [, time])</code></td>
<td>指定时间后调用一次函数，<code>time</code>：毫秒值，默认为 <code>0</code> 即立即执行；通常会给定时器一个标识符，用于清除</td>
</tr>
<tr>
<td><code>clearTimeout(定时器标识符)</code></td>
<td>清除定时器</td>
</tr>
<tr>
<td><code>setInterval(function [, time])</code></td>
<td>每隔指定时间调用一此函数</td>
</tr>
<tr>
<td><code>clearInterval(定时器标识符)</code></td>
<td>清除定时器</td>
</tr>
</tbody></table>
<h3 id="3-滚动"><a href="#3-滚动" class="headerlink" title="3 滚动"></a>3 滚动</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>scrollTo(x-coord, y-coord )</code></td>
<td>滚动到指定位置</td>
</tr>
<tr>
<td><code>scrollBy(x-coord, y-coord)</code></td>
<td>滚动指定距离</td>
</tr>
</tbody></table>
<h2 id="2-4-事件"><a href="#2-4-事件" class="headerlink" title="2.4 事件"></a>2.4 事件</h2><table>
<thead>
<tr>
<th>事件（on+）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>beforeunload</code></td>
<td>窗口关闭前</td>
</tr>
<tr>
<td><code>unload</code></td>
<td>窗口关闭</td>
</tr>
<tr>
<td><code>load</code></td>
<td>窗口加载完毕，包含 dom 元素，图片，flash，css …</td>
</tr>
<tr>
<td><code>DOMContentLoaded</code></td>
<td>DOM 加载完毕，不包含其它，事件源为 <code>document</code></td>
</tr>
<tr>
<td><code>error</code></td>
<td>窗口加载失败</td>
</tr>
<tr>
<td><code>resize</code></td>
<td>窗口大小改变</td>
</tr>
<tr>
<td><code>scroll</code></td>
<td>滚动条滚动</td>
</tr>
</tbody></table>
<h1 id="三-Location"><a href="#三-Location" class="headerlink" title="三 Location"></a>三 Location</h1><h2 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>href</code></td>
<td>当前窗口的 完整 URL，格式： <code>protocal://host[:port]/path/[?query] #fragment</code></td>
</tr>
<tr>
<td><code>protocal</code></td>
<td>协议</td>
</tr>
<tr>
<td><code>host</code></td>
<td>主机:端口（如果端口是默认 <code>80 433</code> 会省略）</td>
</tr>
<tr>
<td><code>hostname</code></td>
<td>主机，不含端口</td>
</tr>
<tr>
<td><code>port</code></td>
<td>端口</td>
</tr>
<tr>
<td><code>pathname</code></td>
<td>资源路径</td>
</tr>
<tr>
<td><code>search</code></td>
<td>参数，<code>?key=value&amp;key=value</code></td>
</tr>
<tr>
<td><code>hash</code></td>
<td>片段，<code>#</code> 后面的内容，如链接 锚点</td>
</tr>
</tbody></table>
<h2 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a>3.2 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>assign(url)</code></td>
<td>重定向，记录浏览历史，可以回退，效果同 <code>href</code> 属性</td>
</tr>
<tr>
<td><code>replace(url)</code></td>
<td>重定向，不记录浏览历史，不能回退</td>
</tr>
<tr>
<td><code>reload([flag])</code></td>
<td>无参或 <code>false</code> 表示刷新 <code>F5</code>，<code>true</code> 表示强制刷新 <code>ctrl + F5</code></td>
</tr>
</tbody></table>
<h1 id="四-Navigator"><a href="#四-Navigator" class="headerlink" title="四 Navigator"></a>四 Navigator</h1><table>
<thead>
<tr>
<th>属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>userAgent</code></td>
<td>只读</td>
<td>客户端发送给服务器的 <code>user-agent</code> 头部的值</td>
</tr>
</tbody></table>
<h1 id="五-History"><a href="#五-History" class="headerlink" title="五 History"></a>五 History</h1><h2 id="5-1-属性"><a href="#5-1-属性" class="headerlink" title="5.1 属性"></a>5.1 属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>会话中的记录条数（可以回退和前进的网页数量）</td>
</tr>
<tr>
<td><code>state</code></td>
<td>当前保留的状态值</td>
</tr>
</tbody></table>
<h2 id="5-2-方法"><a href="#5-2-方法" class="headerlink" title="5.2 方法"></a>5.2 方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>back()</code></td>
<td>后退，等价于 <code>go(-1)</code></td>
</tr>
<tr>
<td><code>forward()</code></td>
<td>前进，等价于 <code>go(1)</code></td>
</tr>
<tr>
<td><code>go([num])</code></td>
<td><code>0</code> 表示刷新，正数表示前进 n 个页面，负数表示后退 n 个页面</td>
</tr>
<tr>
<td><code>pushState(state, title[, url])</code></td>
<td>跳转（不刷新网页）</td>
</tr>
<tr>
<td><code>replaceState(stateObj, title, [url])</code></td>
<td>跳转（不刷新网页且不保存历史）</td>
</tr>
</tbody></table>
<h1 id="六-本地数据存储"><a href="#六-本地数据存储" class="headerlink" title="六 本地数据存储"></a>六 本地数据存储</h1><h2 id="6-1-Storage"><a href="#6-1-Storage" class="headerlink" title="6.1  Storage"></a>6.1  Storage</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>数据存储在用户浏览器中，只能存字符串，以键值对的形式存储</li>
<li>WebStorage 主要提供了一种机制，可以让浏览器提供一种比cookie 更直观的 key、value 存储方式</li>
<li><code>Storage</code> 下有两个子接口 <code>localStorage</code> 和 <code>sessionStorage</code><ol>
<li>关闭网页后重新打开<ul>
<li>localStorage 会保留</li>
<li>sessionStorage 会被删除</li>
</ul>
</li>
<li>在页面内跳转<ul>
<li>localStorage 会保留</li>
<li>sessionStorage 会保留</li>
</ul>
</li>
<li>在页面外跳转（打开新的网页）<ul>
<li>localStorage 会保留</li>
<li>sessionStorage 会被删除</li>
</ul>
</li>
<li>容量<ul>
<li>localStorage ≈ 20M</li>
<li>sessionStorage ≈ 5M</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2 属性"></a>2 属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>只读，保存的数据项个数</td>
</tr>
</tbody></table>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>setItem(key, value)</code></td>
<td>存储数据，只能存字符串</td>
</tr>
<tr>
<td><code>getItem(key)</code></td>
<td>获取数据</td>
</tr>
<tr>
<td><code>removeItem(key)</code></td>
<td>移除数据</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空</td>
</tr>
<tr>
<td><code>key(index)</code></td>
<td>返回指定索引的键，从 0 开始</td>
</tr>
</tbody></table>
<h2 id="6-2-IndexedDB"><a href="#6-2-IndexedDB" class="headerlink" title="6.2 IndexedDB"></a>6.2 IndexedDB</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>客户端通常会存储一些简单的数据到本地（浏览器中），比如token、用户名、密码、用户信息等，但比较少存储大量的数<br>据，如果确实有大量的数据需要存储，可以选择使用 IndexedDB</li>
<li>IndexedDB 是一种底层的 API，用于在客户端存储大量的结构化数据</li>
<li>IndexedDB 是一种事务型数据库系统，是一种基于 JavaScript 面向对象数据库，有点类似于 NoSQL（非关系型数据库）</li>
<li>IndexedDB 本身就是基于事务的，我们只需要指定数据库模式，打开与数据库的连接，然后检索和更新一系列事务即可</li>
</ol>
<h3 id="2-连接数据库"><a href="#2-连接数据库" class="headerlink" title="2 连接数据库"></a>2 连接数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 1 打开 indexedDB 的某一个数据库，存在则打开，不存在则创建</span><br><span class="line">const dbRequest = indexDB.open(数据库名称[, 数据库版本])</span><br><span class="line"></span><br><span class="line">// 2 第一次打开或版本更新回调</span><br><span class="line">dbRequest.onupgradeneeded = function(event)&#123;</span><br><span class="line">	cosnt db = event.target.result;</span><br><span class="line">	// 相当于创建 表，并设置主键</span><br><span class="line">	db.createObjectStore(存储名称, &#123;keyPath: &quot;id&quot;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 3 成功打开回调</span><br><span class="line">let db = null;</span><br><span class="line">dbRequest.onsuccess = function(event)&#123;</span><br><span class="line">	db = event.target.result;</span><br><span class="line">&#125;</span><br><span class="line">// 4 失败回调</span><br><span class="line">dbRequest.onerror = function(err)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-操作"><a href="#3-操作" class="headerlink" title="3 操作"></a>3 操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 1 操作步骤</span><br><span class="line">// 1.1 通过 db 获取存储的事务</span><br><span class="line">const transaction = db.transaction(存储名称，读写权限)</span><br><span class="line">// 1.2 通过事务获取对应的存储对象</span><br><span class="line">cosnt store = transaction.objectStore(存储名称)</span><br><span class="line"></span><br><span class="line">// 2 增</span><br><span class="line">store.add(value)</span><br><span class="line">transaction.oncomplete = function(event) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 3 查</span><br><span class="line">// 3.1 根据主键查询</span><br><span class="line">const request = store.get(id)</span><br><span class="line">request.onsuccess = (event) =&gt; &#123;</span><br><span class="line">	const res = event.target.result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.2 多个查询 （获取游标）</span><br><span class="line">const request = store.openCursor()</span><br><span class="line">request.onsuccess = (event) =&gt; &#123;</span><br><span class="line">	const cursor = event.target.result</span><br><span class="line">	if(cursor) &#123;</span><br><span class="line">		console.log(cursor.key, cursor.value)</span><br><span class="line">		// 继续执行</span><br><span class="line">		cursor.continue</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		console.log(&quot;查询完成&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4 删</span><br><span class="line">const request = store.openCursor()</span><br><span class="line">request.onsuccess = (event) =&gt; &#123;</span><br><span class="line">	const cursor = event.target.result</span><br><span class="line">	if(cursor) &#123;</span><br><span class="line">		cursor.delete();</span><br><span class="line">		cursor.continue</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		console.log(&quot;删除完成&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5 改</span><br><span class="line">const request = store.openCursor()</span><br><span class="line">request.onsuccess = (event) =&gt; &#123;</span><br><span class="line">	const cursor = event.target.result</span><br><span class="line">	if(cursor) &#123;</span><br><span class="line">		if (cursor.key === 1) &#123;</span><br><span class="line">			const value = cursor.value</span><br><span class="line">			value = &#x27;haha&#x27;;</span><br><span class="line">			cursor.update(value)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cursor.continue</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/06-JS%E5%BC%82%E6%AD%A5%E5%92%8C%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/06-JS%E5%BC%82%E6%AD%A5%E5%92%8C%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">06-JS异步和模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-14 19:57:35 / 修改时间：19:59:37" itemprop="dateCreated datePublished" datetime="2022-02-14T19:57:35+08:00">2022-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-promise"><a href="#一-promise" class="headerlink" title="一 promise"></a>一 promise</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果</li>
<li>Promise 的三种状态<ol>
<li>pending：待定状态，初始化时的状态</li>
<li>fulfilled：异步操作成功</li>
<li>rejected：异步操作失败</li>
</ol>
</li>
<li>promise 状态的改变是一次性的，一旦从 pending 变成 fulfilled 或 rejected，该 Promise 的状态不再可更改</li>
<li>promise 的结果：<ol>
<li>成功的值</li>
<li>失败的原因</li>
</ol>
</li>
</ol>
<h2 id="1-2-构造函数"><a href="#1-2-构造函数" class="headerlink" title="1.2 构造函数"></a>1.2 构造函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Promise(executor)</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(value)</span><br><span class="line">    reject(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>executor</code>：一个回调函数，其两个参数也是回调函数</li>
<li>Promise 构造函数执行时立即执行 <code>executor</code> 函数</li>
<li><code>executor</code> 的返回值会被忽略</li>
<li>创建出的 promise 的状态<ol>
<li>如果 <code>executor</code> 内部有错误抛出，promise 状态会变为 <code>rejected</code></li>
<li>调用 reject 方法，无论传入什么值只会影响 promise 的结果，promise 状态都会变为 rejected</li>
<li>调用 resolve 方法<ol>
<li>传入一个普通值（包括 undefined、对象、…）：当前 promise 状态变为 fulfilled，结果为此值</li>
<li>传入一个 thenable 对象（对象实现了 then 方法）：会执行该对象的 then 方法，当前 promise 状态根据 then 方法的结果来决定</li>
<li>传入一个 Promise，当前 promise 状态由传入的 Promise 状态决定</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="1-3-原型方法"><a href="#1-3-原型方法" class="headerlink" title="1.3 原型方法"></a>1.3 原型方法</h2><h3 id="1-then"><a href="#1-then" class="headerlink" title="1 then"></a>1 then</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.then(onFulfilled[, onRejected]);</span><br><span class="line"></span><br><span class="line">p.then(value =&gt; &#123;</span><br><span class="line">  // fulfillment</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">  // rejection</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>当 promise 状态为 fulfilled 时执行 onFulfilled 函数</li>
<li>当 promise 状态为 rejected 时执行 onRejected 函数</li>
<li>onFulfilled 和 onRejected 函数的参数分别接收成功和失败的结果</li>
<li>一个 promise 的 then 方法可以被调用多次，当 Promise 的状态变成 fulfilled 的时候，这些 then 的回调函数都会被执行</li>
<li>then 方法的返回值是一个新的 promise<ol>
<li>当 then 方法中的回调函数本身在执行的时候，新的 promise 处于 pending 状态</li>
<li>当 then 方法抛出一个异常时，新的 promise 为 rejected 状态</li>
<li>then 方法执行完毕（无论是 onFulfilled 还是 onRejected）返回一个结果，此结果会作为新的 promise 的 resolve 函数的参数。resolve 函数接受参数有三种情况，所以新的 promise 的状态根据 then 方法返回值不同也分三种情况<ol>
<li>返回一个普通的值（包含默认返回的 undefined），promise 状态变为 fulfilled，结果为此值</li>
<li>返回一个 thenable 对象，根据  then 方法的结果来决定新 promsie 的状态</li>
<li>返回一个 promise，新 promsie 的状态由返回的 promise 决定</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-catch"><a href="#2-catch" class="headerlink" title="2 catch"></a>2 catch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">catch(onRejected)</span><br><span class="line"></span><br><span class="line">catch(reason =&gt; &#123;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line">then(undefined, onRejected)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>一个 Promise 的 catch方法是可以被多次调用的，当 Promise 的状态变成 rejected 的时候，这些回调函数都会被执行</p>
</li>
<li><p>catch 返回一个 promise，其状态与 then 方法的情况一样</p>
<ol>
<li>如果 onRejected 返回一个 rejected 状态的 Promise 或着抛出一个错误，则 catch 返回的 promise 状态为 rejected</li>
<li>否则，catch 返回的 promise 状态为 fulfilled</li>
</ol>
</li>
<li><p>链式调用时，catch 之前任一 promise 状态变为 rejected，如果此 promise自己没有处理，则会被 catch 捕获 </p>
</li>
</ol>
<h3 id="3-finally"><a href="#3-finally" class="headerlink" title="3 finally"></a>3 finally</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">finally(onFinally)</span><br><span class="line"></span><br><span class="line">finally(() =&gt; &#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>Promise 结束后，无论状态是 fulfilled 还是 rejected，都会执行 finally 中的 onFinally 回调函数</li>
<li>onFinally 函数不接收参数</li>
<li>返回一个设置了 finally 回调函数的 Promise 对象，但通常用不到</li>
</ol>
<h2 id="1-4-静态方法"><a href="#1-4-静态方法" class="headerlink" title="1.4 静态方法"></a>1.4 静态方法</h2><h3 id="1-resolve"><a href="#1-resolve" class="headerlink" title="1 resolve"></a>1 resolve</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(value)</span><br></pre></td></tr></table></figure>

<ol>
<li>返回一个以给定值解析后的 Promise 对象</li>
<li>用法相当于 new Promise，并且执行 resolve 操作（value 有三种情况）</li>
</ol>
<h3 id="2-reject"><a href="#2-reject" class="headerlink" title="2 reject"></a>2 reject</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(reason)</span><br></pre></td></tr></table></figure>

<ol>
<li>返回一个带有拒绝原因的 Promise 对象</li>
<li>用法相当于 new Promise，并且执行 reject 操作</li>
</ol>
<h3 id="3-all"><a href="#3-all" class="headerlink" title="3 all"></a>3 all</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.all(iterable);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将多个 promise 包裹在一起形成一个新的 promise 对象</p>
</li>
<li><p>新的 promise 对象状态由包裹的所有 Promise 共同决定</p>
<ol>
<li>当所有的 Promise 状态变成 fulfilled 状态时，新的 Promise 状态为 fulfilled，并且会将所有 Promise 的返回值组成一个数组；</li>
<li>当有一个 Promise 状态为 rejected 时，新的 Promise 状态为 rejected，并且会将第一个 rejected 的返回值作为结果</li>
</ol>
</li>
<li><p>iterable 的不同情况：iterable 中非 promise 元素会被转为 promise</p>
<ol>
<li><p>一个空的可迭代对象：新的 promise 状态为 fulfilled，结果为空数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promis.all([]).then(</span><br><span class="line">	value =&gt; console.log(value), // []</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>不包含任何 promise：新的 promise 状态为 fulfilled，结果为由参数的元素构成的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promis.all(&quot;abc&quot;).then(</span><br><span class="line">	value =&gt; console.log(value), // [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>包含有 promise</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 1 包含的所有 promise 都成功，则新的 promise 状态为 fulfilled，结果为所有 promise 的成功结果和非promise的值组成的数组</span><br><span class="line"></span><br><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	resolve(&#x27;p1-success&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &#x27;abc&#x27;]).then(</span><br><span class="line">	value =&gt; console.log(value), // [&#x27;p1-success&#x27;,3,4,&#x27;abc&#x27;]</span><br><span class="line">	reason =&gt; console.log(reason)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">// 2 包含的promise 有一个失败，则新的 promise 状态为 rejected，结果为第一个失败的 promise 的失败原因</span><br><span class="line"></span><br><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	reject(&#x27;p1-fail&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">Promis.all([p1, 3, 4, &#x27;abc&#x27;]).then(</span><br><span class="line">	value =&gt; console.log(value), </span><br><span class="line">	reason =&gt; console.log(reason) // p1-fail</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="4-allSettled"><a href="#4-allSettled" class="headerlink" title="4 allSettled"></a>4 allSettled</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.allSettled(iterable)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>all 方法有一个缺陷：当有其中一个 Promise 变成 rejected 状态时，新 Promise 就会立即变成 rejected 状态，对于 resolved 状态以及依然处于 pending 状态的 Promise，我们是获取不到对应的结果的</p>
</li>
<li><p>allSettled</p>
<ol>
<li><p>会在所有的 Promise 都有结果（无论是 fulfilled，还是 rejected）后，才会有最终的状态</p>
</li>
<li><p>返回的新的 promise 一定是 fulfilled 状态，其结果是一个数组，每个数组元素是一个对应 promise 结果的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;status: &quot;fulfilled&quot;, value: ...&#125;</span><br><span class="line">    &#123;status: &quot;rejected&quot;, reason: ...&#125;</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="5-race"><a href="#5-race" class="headerlink" title="5 race"></a>5 race</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.race(iterable)</span><br></pre></td></tr></table></figure>

<ol>
<li>返回一个 promise，此 promise 结果取决于 iterable 参数中的 promise 成功/失败的最快的那个</li>
<li>如果有一个 Promise 有了结果，我们就希望决定最终新 Promise 的状态，也就是说多个 Promise 相互竞争，谁先有结果，那么就使用谁的结果</li>
</ol>
<h3 id="6-any"><a href="#6-any" class="headerlink" title="6 any"></a>6 any</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.any(iterable)</span><br></pre></td></tr></table></figure>

<ol>
<li>any 会等到 iterable 参数中的 promise 有一个状态变为 fulfilled，则将新的 promise 状态变为 fulfilled</li>
<li>如果 iterable 参数中所有的 Promise 都是 rejected 的，那么会等到所有的 Promise 都变成 rejected 状态后，报一个 AggregateError 的错误</li>
</ol>
<h1 id="二-迭代器"><a href="#二-迭代器" class="headerlink" title="二 迭代器"></a>二 迭代器</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>迭代器是用来对某个数据结构进行遍历的对象，让我们无需关心数据结构内部的实现细节</li>
<li>迭代器对象需要符合迭代器协议（<strong>iterator protocol</strong>）<ol>
<li>迭代器协议定义了产生一系列值（无论是有限还是无限个）的标准方式</li>
<li>在 JS 中标准为：具有特定 <code>next()</code> 方法的对象就是一个迭代器</li>
</ol>
</li>
<li><code>next()</code> 方法的要求<ol>
<li>参数：无参或一个参数</li>
<li>返回值：拥有以下两个属性的对象<ol>
<li>done（boolean）<ul>
<li>false：迭代器可以产生序列中的下一个值，即迭代没结束，可以省略</li>
<li>true：迭代完毕，此时 value 可省略</li>
</ul>
</li>
<li>value：迭代器返回的任何 JavaScript 值</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="2-2-可迭代对象"><a href="#2-2-可迭代对象" class="headerlink" title="2.2 可迭代对象"></a>2.2 可迭代对象</h2><ol>
<li>当一个对象实现了 <strong>iterable protocol</strong> 协议时，它就是一个可迭代对象</li>
<li>JS 中一个可迭代对象必须实现 <code>@@iterator</code> 方法，这意味着对象（或其原型链上的某个对象）必须有一个键为 <code>@@iterator</code> 的属性<ol>
<li>此属性指向一个函数，用于获取对象的迭代器</li>
<li>此属性可以通过 <code>Symbol.iterator</code> 访问，对象（或者其原型链）上拥有 <code>Symbol.iterator</code> 属性，就是可迭代对象</li>
<li><code>const iterator = obj[Symbol.iterator]()</code></li>
</ol>
</li>
</ol>
<h2 id="2-3-内置可迭代对象"><a href="#2-3-内置可迭代对象" class="headerlink" title="2.3 内置可迭代对象"></a>2.3 内置可迭代对象</h2><table>
<thead>
<tr>
<th>内置可迭代对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String</code></td>
<td>字符串</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组</td>
</tr>
<tr>
<td><code>Set / Map</code></td>
<td>集合</td>
</tr>
<tr>
<td><code>arguments</code></td>
<td>类数组对象</td>
</tr>
<tr>
<td><code>DOM NodeList</code></td>
<td>类数组对象</td>
</tr>
<tr>
<td><code>Generator</code></td>
<td>生成器对象</td>
</tr>
<tr>
<td><code>TypedArray</code></td>
<td>类型化数组</td>
</tr>
</tbody></table>
<ol>
<li>可枚举属性：属性描述符 <code>enumerable: true</code> 的属性</li>
<li>普通对象：没有数字键和 <code>length</code> 属性的对象</li>
<li>类数组对象：存在数值键名和 <code>length</code> 属性的对象</li>
<li>可迭代对象：实现了 <strong>iterable protocol</strong> 协议的对象</li>
</ol>
<h2 id="2-4-for…of"><a href="#2-4-for…of" class="headerlink" title="2.4 for…of"></a>2.4 for…of</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let value of iterable) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>用来遍历可迭代对象，每次循环取出的是值</li>
<li>for… of 内部就是调用了可迭代对象的 <code>Symbol.iterator</code> 生成了迭代器</li>
</ol>
<h3 id="2-自定义-for…of"><a href="#2-自定义-for…of" class="headerlink" title="2 自定义 for…of"></a>2 自定义 for…of</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myForOf</span>(<span class="params">iterableObj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 1 获取迭代器</span></span><br><span class="line">	<span class="keyword">let</span> it = iterableObj[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">    <span class="comment">// 2 判断迭代是否结束</span></span><br><span class="line">	<span class="keyword">let</span> res = it.next();</span><br><span class="line">	<span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">		<span class="comment">// 3 获取值</span></span><br><span class="line">	    <span class="built_in">console</span>.log(res.value);</span><br><span class="line">	    res = it.next();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-迭代器的中断"><a href="#2-5-迭代器的中断" class="headerlink" title="2.5 迭代器的中断"></a>2.5 迭代器的中断</h2><ol>
<li><p>迭代器在某些情况下会在没有完全迭代的情况下中断</p>
<ol>
<li>比如遍历的过程中通过 break、continue、return、throw 中断了循环操作</li>
<li>比如在解构的时候，没有解构所有的值</li>
</ol>
</li>
<li><p>如果想要监听中断的话，可以在迭代器对象中添加 return 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	next() &#123;</span><br><span class="line">		return &#123;done: false, value: 123&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line">	return() &#123;</span><br><span class="line">		console.log(&#x27;迭代器提前终止了&#x27;);</span><br><span class="line">		// 也需要返回值</span><br><span class="line">		return &#123;done: true&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="三-生成器"><a href="#三-生成器" class="headerlink" title="三 生成器"></a>三 生成器</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* generator() &#123;</span><br><span class="line">  yield 1;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gen = generator(); // &quot;Generator &#123; &#125;&quot;</span><br><span class="line"></span><br><span class="line">console.log(gen.next().value); // 1</span><br><span class="line">console.log(gen.next().value); // 2</span><br><span class="line">console.log(gen.next().value); // 3</span><br></pre></td></tr></table></figure>

<ol>
<li>生成器是 ES6 中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等</li>
<li>生成器不能直接创建，而是由生成器函数返回，生成器其实是一种特殊的迭代器，遵循 iterator protocol 和 iterable protocol</li>
<li>生成器函数的调用与普通函数一样，但是和普通的函数有一些区别<ol>
<li>生成器函数需要在 function 的后面加一个符号 *</li>
<li>生成器函数可以通过 yield 关键字来控制函数的执行流程（生成器函数会被 yield 或 return 分段）</li>
<li>生成器函数的返回值是一个 Generator（生成器）</li>
<li>生成器函数调用之后并不执行，而是每调用一次生成器的 next 方法就执行一段</li>
</ol>
</li>
</ol>
<h2 id="3-2-yield-和-yield"><a href="#3-2-yield-和-yield" class="headerlink" title="3.2 yield 和 yield*"></a>3.2 yield 和 yield*</h2><h3 id="1-yield"><a href="#1-yield" class="headerlink" title="1 yield"></a>1 yield</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rv] = yield [expression]</span><br></pre></td></tr></table></figure>

<ol>
<li><code>expression</code>：作为 next 方法返回的对象的 value 属性的值 <code>&#123;value: expression, done: false&#125;</code></li>
<li>rv：<ol>
<li>yield 语句本身没有返回值，即 rv 总是为  undefined</li>
<li>调用 <code>next(value)</code> 函数时，会将参数 value 赋给上一段 yield 语句的 rv</li>
</ol>
</li>
</ol>
<h3 id="2-yield"><a href="#2-yield" class="headerlink" title="2 yield*"></a>2 yield*</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield* expression</span><br></pre></td></tr></table></figure>

<ol>
<li><code>expression</code>：返回一个可迭代对象</li>
<li>yield* 相当于是一种 yield 的语法糖，只不过会依次迭代这个可迭代对象</li>
</ol>
<h2 id="3-2-原型方法"><a href="#3-2-原型方法" class="headerlink" title="3.2 原型方法"></a>3.2 原型方法</h2><h3 id="1-next"><a href="#1-next" class="headerlink" title="1 next"></a>1 next</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next(value)</span><br></pre></td></tr></table></figure>

<ol>
<li>用来迭代执行生成器函数的每一段</li>
<li>参数：value 会传给上一段 yield 语句的 rv</li>
<li>返回值：一个带有 done 和 value 属性的对象，其中 value 就是 yield 表达式的返回值</li>
</ol>
<h3 id="2-return"><a href="#2-return" class="headerlink" title="2 return"></a>2 return</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return(value)</span><br></pre></td></tr></table></figure>

<ol>
<li>return 传值后这个生成器函数就会结束，之后调用 next 不会继续生成值</li>
<li>参数：value 即返回对象的 value 属性的值</li>
<li>返回一个对象：<code>&#123;value: value, done: true&#125;</code></li>
</ol>
<h3 id="3-throw"><a href="#3-throw" class="headerlink" title="3 throw"></a>3 throw</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw(exception)</span><br></pre></td></tr></table></figure>

<ol>
<li>可以给生成器内部抛出异常</li>
<li>返回值：一个带有 done 和 value 属性的对象</li>
<li>如果用 try…catch 处理，也相当于进行了一次迭代</li>
</ol>
<h1 id="四-async-await"><a href="#四-async-await" class="headerlink" title="四 async / await"></a>四 async / await</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>async / await 是 Generator 的语法糖<ul>
<li>sync 是 synchronous 单词的缩写，表示同步、同时</li>
<li>async 是 asynchronous 单词的缩写，表示异步、非同步</li>
</ul>
</li>
<li>async 用来声明一个异步函数，await 操作符只能用在异步函数中</li>
</ol>
<h2 id="4-2-异步函数的声明"><a href="#4-2-异步函数的声明" class="headerlink" title="4.2 异步函数的声明"></a>4.2 异步函数的声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">async function show()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let show = async function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">let show = async () =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">	async show()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class xxx&#123;</span><br><span class="line">	async show() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>异步函数的执行过程和普通的函数是一致的，默认情况下也是会被同步执行（直到遇到 await）</li>
<li>异步函数会返回一个新的 promise<ol>
<li>异步函数如果抛出了一个异常，程序并不会像普通函数一样报错，而是会将返回的 promise 状态改为 rejected，可以调用catch 来处理</li>
<li>异步函数内部显式的返回值有多种情况，决定了返回的新的promise 的状态<ol>
<li>返回一个普通值，新的 promise 状态为 fulfilled</li>
<li>返回一个 thenable 对象，新的 promise 的状态由对象的then 方法来决定</li>
<li>返回一个 promise，新的 promise 的状态会由返回的 promise 决定</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="4-3-await"><a href="#4-3-await" class="headerlink" title="4.3 await"></a>4.3 await</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[return_value] = await expression;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>await 语句会返回一个 promise，return_value 用于接收 promise 的结果</p>
<ol>
<li>一旦 await 表达式 promise 状态变为 rejected，会直接决定异步函数返回的 promise 的状态，需要 try…catch 或 catch 处理</li>
<li>expression<ol>
<li>普通值</li>
<li>thenable 对象</li>
<li>promise</li>
</ol>
</li>
</ol>
</li>
<li><p>await 会暂停当前 async function 的执行，等待表达式的 promise 处理完成才会继续向下执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[return_value1] = await expression1;</span><br><span class="line">console.log(&#x27;后续代码1&#x27;)</span><br><span class="line">console.log(&#x27;后续代码2&#x27;)</span><br><span class="line">console.log(&#x27;后续代码3&#x27;)</span><br><span class="line">[return_value2] = await expression2;</span><br><span class="line"></span><br><span class="line">* 执行到第一个 await 会等待，直到其表达式的 promise 处理完毕，之后会向下执行直到遇到下一个 await</span><br><span class="line">* 也就是说当前 await 和下一个 await 之间的代码，就相当于当前 await 表达式的 promise 的 then 方法中的代码</span><br></pre></td></tr></table></figure></li>
<li><p>await的并行</p>
<ol>
<li>让promise先执行后再使用await处理结果</li>
<li>使用 Promise.all() 处理多个promise并行执行</li>
</ol>
</li>
</ol>
<h1 id="五-事件循环"><a href="#五-事件循环" class="headerlink" title="五 事件循环"></a>五 事件循环</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>JavaScript是单线程的，但是 JavaScript 的线程应该有自己的容器进程：浏览器或者Node</li>
<li>目前多数的浏览器其实都是多进程的，当我们打开一个tab页面时就会开启一个新的进程，这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出，浏览器每个进程中又有很多的线程，其中包括执行 JavaScript 代码的线程</li>
<li>JavaScript的代码执行是在一个单独的线程中执行的<ol>
<li>意味着JavaScript的代码，在同一个时刻只能做一件事，如果这件事是非常耗时的，JavaScript 线程就会被阻塞</li>
<li>所以真正耗时的操作，实际上并不是由 JavaScript 线程执行的，可以由浏览器的其他线程来完成</li>
</ol>
</li>
</ol>
<h2 id="5-2-任务"><a href="#5-2-任务" class="headerlink" title="5.2 任务"></a>5.2 任务</h2><h3 id="1-任务分类"><a href="#1-任务分类" class="headerlink" title="1 任务分类"></a>1 任务分类</h3><h4 id="1-根据类型分"><a href="#1-根据类型分" class="headerlink" title="1 根据类型分"></a>1 根据类型分</h4><ol>
<li>同步任务<ol>
<li>在主线程上排队执行的任务，形成一个执行栈</li>
<li>前一个任务执行完毕，才能执行后一个任务</li>
</ol>
</li>
<li>异步任务<ol>
<li>JS 的异步是通过回调函数实现的</li>
<li>异步任务相关回调函数会进入任务队列（消息队列）</li>
<li>异步任务不具有“堵塞”效应</li>
<li>异步任务通常有三种<ol>
<li>普通事件，如 <code>click resize ...</code></li>
<li>资源加载，如 <code>load, error ...</code></li>
<li>定时器</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="2-根据机制分"><a href="#2-根据机制分" class="headerlink" title="2 根据机制分"></a>2 根据机制分</h4><ol>
<li>宏任务（macrotask）<ol>
<li>整个脚本代码（第一个宏任务）</li>
<li>ajax</li>
<li>定时器（setTimeout setInterval ..）</li>
<li>DOM 监听</li>
<li>事件 I/O</li>
<li>UI Rendering（渲染）</li>
<li>…</li>
</ol>
</li>
<li>微任务（microtask）<ol>
<li><code>promise.then</code></li>
<li>Mutation Observer API</li>
<li>queueMicrotask()</li>
<li>…</li>
</ol>
</li>
</ol>
<h3 id="2-任务队列"><a href="#2-任务队列" class="headerlink" title="2 任务队列"></a>2 任务队列</h3><ol>
<li><p>任务队列（task queue）</p>
<ul>
<li>用于存放异步任务</li>
<li>根据异步任务的类型，可以存在多个任务队列<ol>
<li>宏任务队列（macrotask queue）</li>
<li>微任务队列（microtask queue）</li>
</ol>
</li>
</ul>
</li>
<li><p>事件循环（Event Loop）</p>
<ul>
<li>主线程栈执行完毕后，引擎会在任务队列循环检查，如果有可以执行的异步任务，则结束等待状态，进入主线程开始执行</li>
</ul>
</li>
</ol>
<h2 id="5-3-浏览器的事件循环"><a href="#5-3-浏览器的事件循环" class="headerlink" title="5.3 浏览器的事件循环"></a>5.3 浏览器的事件循环</h2><p>![](D:\唯手熟尔\02-CS\03-招式\01-前端\03-JavaScript\img\JS 执行机制.png)</p>
<ol>
<li>原则：<ol>
<li>任何一个宏任务开始执行前，微任务队列必须为空</li>
<li>每个任务执行时，其内部代码中：<ol>
<li>同步任务代码直接执行</li>
<li>异步任务根据其是宏任务还是微任务，交给各自异步处理进程，当满足条件时（如 事件触发，定时器到时…）<ol>
<li>宏任务进入宏任务队列 <code>macrotask queue</code></li>
<li>微任务进入微任务队列 <code>microtask queue</code></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>执行过程<ol>
<li>整个脚本代码（main script）作为第一个宏任务开始执行（刚开始，微任务队列为空）</li>
<li>事件循环微任务队列，依次读入主线程执行栈并执行（清空微任务队列）</li>
<li>事件循环宏任务队列，将一个宏任务读入主线程执行栈执行</li>
<li>重复 2、3，直到任务队列都清空</li>
</ol>
</li>
</ol>
<h2 id="5-4-Node-的事件循环"><a href="#5-4-Node-的事件循环" class="headerlink" title="5.4 Node 的事件循环"></a>5.4 Node 的事件循环</h2><ol>
<li>浏览器中的 EventLoop 是根据 HTML5 定义的规范来实现的，不同的浏览器可能会有不同的实现，而 Node 中是由 libuv 实现的</li>
<li>Node 一次完整的事件循环 Tick 分成很多个阶段<ol>
<li>定时器（Timers）：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数</li>
<li>轮询（Poll）：检索新的 I/O 事件；执行与 I/O 相关的回调</li>
<li>检测（check）：setImmediate() 回调函数在这里执行</li>
<li>待定回调（Pending Callback）：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到ECONNREFUSED</li>
<li>idle, prepare：仅系统内部使用</li>
<li>关闭的回调函数：一些关闭的回调函数，如：socket.on(‘close’, …)。</li>
</ol>
</li>
<li>Node中的事件循环不只是 微任务队列和 宏任务队列<ol>
<li>微任务队列<ol>
<li>next tick queue：process.nextTick</li>
<li>other queue：Promise的then回调、queueMicrotask</li>
</ol>
</li>
<li>宏任务队列<ol>
<li>timer queue：setTimeout、setInterval</li>
<li>poll queue：IO事件</li>
<li>check queue：setImmediate</li>
<li>close queue：close事件</li>
</ol>
</li>
</ol>
</li>
<li>Node事件循环的顺序<ol>
<li>next tick microtask queue</li>
<li>other microtask queue</li>
<li>timer queue</li>
<li>poll queue</li>
<li>check queue</li>
<li>close queue</li>
</ol>
</li>
</ol>
<h1 id="六-模块"><a href="#六-模块" class="headerlink" title="六 模块"></a>六 模块</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ol>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000015302578">网上概述</a></li>
<li>什么是模块化、模块化开发<ul>
<li>模块化开发最终的目的是将程序划分成一个个小的结构</li>
<li>每个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构</li>
<li>每个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用，也可以通过某种方式，导入另外结构中的变量、函数、对象等</li>
<li>上述结构，就是模块；按照这种结构划分开发程序的过程，就是模块化开发的过程</li>
</ul>
</li>
<li>ES6 之前 JS 本身没有模块化，为了让 JS 支持模块化，涌现出了很多不同的模块化规范<ul>
<li><code>CommonJS</code>：用于 Node.js</li>
<li><code>AMD</code>：主要用于浏览器，AMD 规范的常见实现 <code>require.js</code> 和 <code>curl.js</code></li>
<li><code>CMD</code>：主要用于浏览器，CMD 规范的常见实现 <code>SeaJS</code></li>
</ul>
</li>
</ol>
<h2 id="6-2-CommonJS"><a href="#6-2-CommonJS" class="headerlink" title="6.2 CommonJS"></a>6.2 CommonJS</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>CommonJS 是一个<strong>规范</strong>，最初提出来是在浏览器以外的地方使用，并且当时被命名为 ServerJS，后来为了体现它的广泛性，修改为 CommonJS，也会简称为 CJS</li>
<li>CommonJS 是一个<strong>规范</strong>，有不同的<strong>实现</strong><ol>
<li>Node 是CommonJS 在服务器端一个具有代表性的<strong>实现</strong>，Node 中每一个js文件都是一个单独的模块</li>
<li>Browserify 是 CommonJS 在浏览器中的一种<strong>实现</strong></li>
<li>webpack 打包工具具备对 CommonJS 的支持和转换</li>
</ol>
</li>
</ol>
<h3 id="2-导出"><a href="#2-导出" class="headerlink" title="2  导出"></a>2  导出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;&#125;</span><br><span class="line">exports = module.exports</span><br></pre></td></tr></table></figure>

<ol>
<li>只要将需要导出的内容添加到 <code>module.exports</code> 对象上即可</li>
<li><code>exports</code> 只是 <code>module.exports</code> 对象的一个变量引用，注意：<ol>
<li>只有 <code>module.exports</code> 对象才能导出</li>
<li>由于 <code>exports</code> 指向 <code>module.exports</code>，所以向 <code>exports</code> 上添加属性也可以导出</li>
<li>但如果给 <code>exports</code> 赋一个对象，相当于修改了它的指向，那么导出就跟它无关了，当然就无法导出</li>
</ol>
</li>
<li>导入函数的返回值指向了 <code>module.exports</code> 对象</li>
</ol>
<h3 id="3-导入"><a href="#3-导入" class="headerlink" title="3 导入"></a>3 导入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(X)</span><br></pre></td></tr></table></figure>

<ol>
<li>X 是一个 Node核心模块，比如 path、http，直接返回核心模块，并且停止查找</li>
<li>X 是以 ./ 或 ../ 或 /（根目录）开头的路径<ol>
<li>将X当做一个文件在对应的目录下查找<ol>
<li>如果有后缀名，按照后缀名的格式查找对应的文件</li>
<li>如果没有后缀名<ol>
<li>查找 X 文件</li>
<li>查找 X.js 文件</li>
<li>查找 X.json 文件</li>
<li>查找 X.node 文件</li>
</ol>
</li>
</ol>
</li>
<li>没有找到对应的文件，则将 X 作为一个目录，并在目录下<ol>
<li>查找 X/index 文件</li>
<li>查找 X/index.js 文件</li>
<li>查找 X/index.json 文件</li>
<li>查找 X/index.node 文件</li>
</ol>
</li>
<li>没有找到，那么报错：not found</li>
</ol>
</li>
<li>X 不是路径也不是一个核心模块（通常用于第三方包）<ol>
<li>从当前路径开始，每次往上一层，直到根路径，在每个路径下查找 <code>/node_modules/X</code></li>
<li>若找到，X 如果是一个文件夹则会自动拼接 <code>X/index.js</code></li>
<li>若未找到，报错：not found</li>
</ol>
</li>
</ol>
<h3 id="4-Node-中模块加载过程"><a href="#4-Node-中模块加载过程" class="headerlink" title="4 Node 中模块加载过程"></a>4 Node 中模块加载过程</h3><ol>
<li>模块在被第一次引入时，模块中的 js 代码会被运行一次</li>
<li>模块被多次引入时，会缓存，最终只加载（运行）一次<ol>
<li>因为每个模块对象 module 都有一个属性：loaded</li>
<li>loaded 为 false 表示还没有加载，为 true 表示已经加载</li>
</ol>
</li>
<li>如果有循环引入，会形成图结构，Node 采用深度优先遍历</li>
<li>CommonJS 加载模块是同步的，意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行<ol>
<li>在服务器不会有什么问题，因为服务器加载的 js 文件都是本地文件，加载速度非常快</li>
<li>浏览器加载 js 文件需要先从服务器将文件下载下来，之后再加载运行，所以在浏览器中，通常不使用 CommonJS 规范（在 webpack 中使用 CommonJS是另外一回事，因为它会将我们的代码转成浏览器可以直接执行的代码）</li>
</ol>
</li>
</ol>
<h2 id="6-3-ES-Module"><a href="#6-3-ES-Module" class="headerlink" title="6.3 ES Module"></a>6.3 ES Module</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p>模块就是一个独立的文件，文件内部的变量，函数，类…外部无法获取</p>
</li>
<li><p>模块都有独立的顶级作用域，不同模块间不能相互访问，类似函数作用域</p>
</li>
<li><p>模块默认运行在严格模式</p>
</li>
<li><p>使用模块可以解决全局变量冲突</p>
</li>
<li><p>模块可以避免滥用全局变量，造成代码不可控</p>
</li>
<li><p>模块的加载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 加载普通 js 文件，内部不能使用模块语法</span><br><span class="line">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 2 将 js 文件当作模块加载</span><br><span class="line">&lt;script src=&quot;index.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">* 异步加载，即模块总是会在所有html解析后才执行</span><br><span class="line">* 模块的加载不能使用 file:// 协议，即不能加载本地模块</span><br></pre></td></tr></table></figure></li>
<li><p>CommonJS 和 ESModule 的相互引用</p>
<ol>
<li>浏览器环境：不行，浏览器不支持 CommonJS</li>
<li>Node环境：看 Node 的版本</li>
<li>webpack环境：可以</li>
</ol>
</li>
</ol>
<h3 id="2-导出-1"><a href="#2-导出-1" class="headerlink" title="2 导出"></a>2 导出</h3><h4 id="1-导出单个"><a href="#1-导出单个" class="headerlink" title="1 导出单个"></a>1 导出单个</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export 声明语句</span><br><span class="line"></span><br><span class="line">// 例</span><br><span class="line">export let name = &#x27;xiaoqiang&#x27;;</span><br><span class="line">export let obj = &#123;&#125;;</span><br><span class="line">export function show() &#123;&#125;;</span><br><span class="line">export class User &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-导出-n-个"><a href="#2-导出-n-个" class="headerlink" title="2 导出 n 个"></a>2 导出 n 个</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 注意：&#123;&#125; 是固定语法，不是对象，导出时可以起别名</span><br><span class="line">export &#123;</span><br><span class="line">	variable1 [as name1],</span><br><span class="line">	variable2 [as name2], </span><br><span class="line">	…, </span><br><span class="line">	variableN [as nameN]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 例</span><br><span class="line">let name = &#x27;xiaoqiang&#x27;;</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">function show() &#123;&#125;;</span><br><span class="line">class User &#123;&#125;</span><br><span class="line"> </span><br><span class="line">export &#123;</span><br><span class="line">	name as userName,</span><br><span class="line">	obj,</span><br><span class="line">	show,</span><br><span class="line">	User</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-导出默认"><a href="#3-导出默认" class="headerlink" title="3 导出默认"></a>3 导出默认</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1 将 expression 的值赋给 default 导出</span><br><span class="line">export default expression;</span><br><span class="line"></span><br><span class="line">// 2 由于默认导出本质是导出一个名为default的属性，所以可以说使用别名的方式实现默认导出</span><br><span class="line">export &#123; variable1 as default, … &#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用<code>import</code>命令时，需要知道<code>export</code>导出的属性名称</li>
<li><code>export default</code> 本质是导出一个名为<code>defualt</code>的属性，使用<code>import</code>导入时可以以任意名称导入</li>
<li>一个模块只能有一个默认导出，可以与普通导出共存</li>
</ol>
<h4 id="4-导出导入"><a href="#4-导出导入" class="headerlink" title="4 导出导入"></a>4 导出导入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export &#123; </span><br><span class="line">	defaultExport，</span><br><span class="line">	export1 [as alias1], </span><br><span class="line">	export2 [as alias2],</span><br><span class="line">	..., </span><br><span class="line">	exportN [as aliasN] </span><br><span class="line">&#125; from &quot;module_path&quot;</span><br><span class="line"></span><br><span class="line">export * from &quot;module_path&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>export 关建字 + import 语法，可以将导入的模块直接导出</li>
<li>相当于一个转发，并没有导入到当前模块，即当前模块不能使用导入导出的功能</li>
</ol>
<h3 id="3-导入-1"><a href="#3-导入-1" class="headerlink" title="3 导入"></a>3 导入</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>import 用于导入其它模块提供的功能。</li>
<li>import 导入的变量名要与export导出的一致</li>
<li>import 导入的变量是只读的</li>
<li>import 命令具有提升效果，会提升到整个模块的头部，首先执行 </li>
<li>import 是静态导入，不能使用表达式和变量</li>
<li>在浏览器中引用模块必须添加路径，但在打包工具如 webpack 中则可能不需要，因为他们有自己的存放方式</li>
<li><code>import.meta</code> 是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象<ul>
<li>在ES11（ES2020）中新增的特性</li>
<li><code>import.meta.url = 当前模块所在的路径</code></li>
</ul>
</li>
</ol>
<h4 id="2-导入指定导出"><a href="#2-导入指定导出" class="headerlink" title="2 导入指定导出"></a>2 导入指定导出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; </span><br><span class="line">	defaultExport，</span><br><span class="line">	export1 [as alias1], </span><br><span class="line">	export2 [as alias2],</span><br><span class="line">	..., </span><br><span class="line">	exportN [as aliasN] </span><br><span class="line">&#125; from &quot;module_path&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>导入默认导出时名称任意</li>
<li>由于默认导出只有一个，所以不需要<code>&#123;&#125;</code></li>
</ol>
<h4 id="3-导入所有导出"><a href="#3-导入所有导出" class="headerlink" title="3 导入所有导出"></a>3 导入所有导出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将 module_path 所有导出导入到 obj 上，使用 default 获取默认导出</span><br><span class="line">import * as obj from &quot;module_path&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4-动态导入"><a href="#4-动态导入" class="headerlink" title="4 动态导入"></a>4 动态导入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import(&#x27;module_path&#x27;)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>静态导入：</p>
<ol>
<li>必须在模块导入完毕才会继续向下执行</li>
<li>静态导入不能放在其它逻辑代码中，因为ES Module在被JS引擎解析时，就必须知道它的依赖关系</li>
</ol>
</li>
<li><p>动态导入：</p>
<ol>
<li>使用<code>import()</code> 函数可以动态导入模块，它返回一个 promise 对象，可以按需加载</li>
<li><code>import()</code> 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块</li>
</ol>
</li>
</ol>
<h3 id="4-ES-Module-原理"><a href="#4-ES-Module-原理" class="headerlink" title="4 ES Module 原理"></a>4 ES Module 原理</h3><p><img src="D:\学无止境\00-教程\coderwhy\01-前端\03-JavaScript\img\ES模块阶段一.png"></p>
<p><img src="D:\学无止境\00-教程\coderwhy\01-前端\03-JavaScript\img\ES模块阶段二三.png"></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">参考文章</a></li>
<li>ES Module的解析过程可以划分为三个阶段<ol>
<li>构建（Construction）：根据地址查找js文件，并且下载，将其解析成模块记录（Module Record）</li>
<li>实例化（Instantiation）：对模块记录进行实例化，并且分配内存空间，解析模块的导入和导出语句，把模块指向<br>对应的内存地址</li>
<li>运行（Evaluation）：运行代码，计算值，并且将值填充到内存地址中</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/05-JS%E5%8E%9F%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/05-JS%E5%8E%9F%E5%9E%8B/" class="post-title-link" itemprop="url">05-JS原型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-14 19:57:26 / 修改时间：19:59:32" itemprop="dateCreated datePublished" datetime="2022-02-14T19:57:26+08:00">2022-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-原型"><a href="#1-1-原型" class="headerlink" title="1.1 原型"></a>1.1 原型</h2><p><img src="D:\学无止境\00-教程\coderwhy\01-前端\03-JavaScript\img\原型.png"></p>
<h3 id="1-proto"><a href="#1-proto" class="headerlink" title="1 __proto__"></a>1 <code>__proto__</code></h3><ol>
<li><p><code>__proto__</code> 是浏览器实现的非 JavaScript 标准的属性，在ES6写入了附录，用于获取或设置对象的原型，由于非标准，浏览器有这个属性，其它环境未必有。建议使用 Object中 的方法 替代<code> __proto__</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="built_in">Object</span>.getPrototypeOf(obj)</span><br><span class="line">- <span class="built_in">Object</span>.setPrototypeOf(obj, prototype)</span><br><span class="line">- <span class="built_in">Object</span>.create(proto[, propertiesObject])</span><br></pre></td></tr></table></figure></li>
<li><p><code>obj.__proto__</code> 并非是普通的属性访问方式，而是通过 <code>getter/setter</code> 访问器，可以理解为 <code>prototype</code> 属性的 <code>getter/setter</code> 实现</p>
</li>
<li><p>每个对象都有 <code>__proto__</code> 属性，指向它的构造函数的原型对象，即如果A对象是由B函数构造的，则 <code>A.__proto__ === B.prototype</code></p>
<ol>
<li>普通对象的构造函数是其对应的构造函数，原型对象也是普通对象，其默认构造函数是 Object，则<ul>
<li><code>对象.__proto__ === 构造函数.prototype</code></li>
<li><code>原型对象.__proto__ === Object.prototype</code></li>
</ul>
</li>
<li>原型对象中有两个特殊<ol>
<li> <code>Object.prototype </code>：它是原型链的顶端，<code>Object.prototype.__proto__ === null</code></li>
<li><code>Function.prototype</code><ul>
<li>它是原型对象，但不属于普通对象而属于函数对象</li>
<li>它是函数对象，但它没有 <code>prototype</code> 属性</li>
</ul>
</li>
</ol>
</li>
<li>函数对象（包括 Function 自身）的构造函数是 Function，则 <ul>
<li><code>函数.__proto__ === Function.prototype</code></li>
<li><code>Function.__proto__ === Function.prototype</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-prototype"><a href="#2-prototype" class="headerlink" title="2 prototype"></a>2 <code>prototype</code></h3><ol>
<li>每个构造函数都有 <code>prototype </code> 属性，指向其原型对象，原型对象用于所有实例共享属性和方法</li>
<li>函数作为对象有 <code>__proto__</code> 属性，又可以作为构造函数有<code>prototype</code> 属性</li>
<li>原型的作用是让该构造函数所实例化的对象们都可以找到公用的属性和方法，所以 JS 的继承是通过 <code>prototype</code> 实现的</li>
</ol>
<h3 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3 constructor"></a>3 <code>constructor</code></h3><ul>
<li>只有原型对象才有 <code>constructor</code> 属性，指向对应构造函数<ul>
<li><code>实例对象.__proto__ === 原型对象</code></li>
<li><code>构造函数.prototype === 原型对象</code></li>
<li><code>原型对象.constructor === 构造函数</code></li>
</ul>
</li>
</ul>
<h2 id="1-2-原型链"><a href="#1-2-原型链" class="headerlink" title="1.2 原型链"></a>1.2 原型链</h2><p><img src="D:\学无止境\00-教程\coderwhy\01-前端\03-JavaScript\img\原型链.png"></p>
<ul>
<li>对象有自己的原型对象，而对象又可以充当其他对象的原型，就会形成一个“原型链”（prototype chain）</li>
</ul>
<h2 id="1-3-new"><a href="#1-3-new" class="headerlink" title="1.3 new"></a>1.3 new</h2><h3 id="1-new的执行过程"><a href="#1-new的执行过程" class="headerlink" title="1 new的执行过程"></a>1 new的执行过程</h3><ol>
<li>在内存中创建一个新的对象（空对象）</li>
<li>将新建对象的 <code>__proto__</code> 指向构造函数的原型对象，<code>obj.__proto__ = 构造函数.prototype</code></li>
<li>将构造函数内部的 this 指向新建对象</li>
<li>执行构造函数的内部代码（函数体代码）</li>
<li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li>
</ol>
<h3 id="2-自定义-new"><a href="#2-自定义-new" class="headerlink" title="2 自定义 new"></a>2 自定义 new</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNew = <span class="function"><span class="keyword">function</span>(<span class="params">cons, args</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> obj = &#123;&#125;; <span class="comment">// 步骤1</span></span><br><span class="line">	obj.__proto__ = cons.prototype; <span class="comment">// 步骤2</span></span><br><span class="line">	<span class="comment">// let obj = Object.create(cons.prototype); 步骤1，2合在一起</span></span><br><span class="line">	<span class="keyword">let</span> result = cons.apply(obj, args); <span class="comment">// 步骤3</span></span><br><span class="line">	<span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj; <span class="comment">// 步骤4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-new-target-属性"><a href="#3-new-target-属性" class="headerlink" title="3 new.target 属性"></a>3 <code>new.target</code> 属性</h3><ul>
<li>用来检测函数是否通过<code>new</code>或者<code>Reflect.construct()</code>调用的<ol>
<li>如果在普通函数中使用，返回 <code>undefined</code></li>
<li>在构造函数中使用指向被 new 调用的构造函数</li>
<li>在 <code>class</code> 的 <code>constructor</code> 函数中使用指向被 new 调用的 <code>class</code></li>
</ol>
</li>
</ul>
<h1 id="二-构造函数中的属性和方法"><a href="#二-构造函数中的属性和方法" class="headerlink" title="二 构造函数中的属性和方法"></a>二 构造函数中的属性和方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> age = <span class="number">18</span>; <span class="comment">// 普通属性</span></span><br><span class="line">	<span class="keyword">let</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 普通方法</span></span><br><span class="line">	<span class="built_in">this</span>.name = name; <span class="comment">// 实例属性</span></span><br><span class="line">	<span class="built_in">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">// 实例方法</span></span><br><span class="line">&#125;</span><br><span class="line">User.country = <span class="string">&#x27;中国&#x27;</span>; <span class="comment">// 静态属性</span></span><br><span class="line">User.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 静态方法</span></span><br><span class="line">User.prototype.gender = <span class="string">&#x27;男&#x27;</span>; <span class="comment">// 原型属性</span></span><br><span class="line">User.prototype.change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 原型方法</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>普通属性 / 方法</td>
<td>在构造函数使用 <code>var/let/const</code>声明的属性/方法（只是函数内部的局部变量不属于对象）</td>
</tr>
<tr>
<td>实例属性 / 方法</td>
<td>在构造函数使用<code>this.</code>声明的属性/方法</td>
</tr>
<tr>
<td>静态属性 / 方法</td>
<td>定义在构造函数上的属性/方法</td>
</tr>
<tr>
<td>原型属性 / 方法</td>
<td>定义在构造函数原型上的属性/方法 ，<strong>原型方法默认可枚举</strong></td>
</tr>
</tbody></table>
<h1 id="三-继承"><a href="#三-继承" class="headerlink" title="三 继承"></a>三 继承</h1><h2 id="3-1-继承原理"><a href="#3-1-继承原理" class="headerlink" title="3.1 继承原理"></a>3.1 继承原理</h2><p><img src="D:\学无止境\00-教程\coderwhy\01-前端\03-JavaScript\img\原型继承.png"></p>
<ol>
<li><p>继承就是让父类构造函数的原型出现在子类实例的原型链上</p>
</li>
<li><p>ES6 允许对内置的构造函数如 <code>Object() Array() ...</code> 的继承</p>
</li>
<li><p>设置原型方式</p>
<ol>
<li><p>设置构造函数原型，使用函数的 <code>prototype</code> 属性</p>
</li>
<li><p>设置对象的原型</p>
<ol>
<li><p>Object 的方法，创建对象时指定原型（只是定义无法获取）：<code>Object.create(proto[, propertiesObject])</code> </p>
</li>
<li><p>使用对象的属性<code>__proto__</code> 获取或设置原型，在浏览器之外的环境可能不行。</p>
</li>
<li><p>Object 的方法，与<code>__proto__</code>效果一样，但是是 JS 标准</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(obj)</span><br><span class="line">Object.setPrototypeOf(obj, prototype)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="3-2-实现继承的方式"><a href="#3-2-实现继承的方式" class="headerlink" title="3.2 实现继承的方式"></a>3.2 实现继承的方式</h2><h3 id="1-原型链-1"><a href="#1-原型链-1" class="headerlink" title="1 原型链-1"></a>1 原型链-1</h3><p><img src="D:\学无止境\00-教程\coderwhy\01-前端\03-JavaScript\img\继承1.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.__proto__ = B.prototype;</span><br></pre></td></tr></table></figure>

<ol>
<li>将子类构造函数的原型对象的原型直接指向父类构造函数的原型对象</li>
<li>好处<ul>
<li>父类原型在子类原型链上，则子类可以继承父类的原型属性/方法</li>
</ul>
</li>
<li>弊端<ul>
<li>创建子类时不会调用父类构造函数，无法继承父类的实例属性/方法</li>
</ul>
</li>
</ol>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fu</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">	<span class="built_in">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zi</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	Fu(name,age); <span class="comment">// 不行，因为直接调用时，父类构造函数this是指向window的</span></span><br><span class="line">	Fu.call(<span class="built_in">this</span>, name, age); </span><br><span class="line">	Fu.apply(<span class="built_in">this</span>, [name, age])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在子类构造函数中通过<code>call/apply</code>调用父类构造函数，并指定this为子类对象</p>
</li>
<li><p>好处</p>
<ul>
<li>创建的子类实例具备父类实例属性/方法</li>
</ul>
</li>
<li><p>弊端</p>
<ul>
<li><p>只是子类的实例，不是父类的实例（只是通过调用父类构造函数模拟继承）</p>
</li>
<li><p>无法继承父类原型属性/方法</p>
</li>
</ul>
</li>
</ol>
<h3 id="3-原型链-2"><a href="#3-原型链-2" class="headerlink" title="3 原型链-2"></a>3 原型链-2</h3><p><img src="D:\学无止境\00-教程\coderwhy\01-前端\03-JavaScript\img\继承2.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype = new B();</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将子类构造函数的原型对象修改为一个父类实例（舍弃原有原型对象）</p>
</li>
<li><p>好处</p>
<ul>
<li>父类实例对象是通过父类构造函数创建的，具有父类的实例属性/方法，父类实例对象的原型又指向父类构造函数原型，所以父类的实例属性/方法 和 原型属性/方法，子类都可以继承</li>
</ul>
</li>
<li><p>弊端</p>
<ul>
<li>父类的实例属性/方法是在子类原型对象上，这就导致父类的实例属性/方法实际上变成了子类的原型属性/方法。</li>
<li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li>
</ul>
</li>
<li><p>对新增对象的影响</p>
<ul>
<li>如果新增对象在修改原型操作之前，那就意味着，新增对象指向的原型还是原来被舍弃的原型，所以这种方式只对修改原型操作之后新增的对象有效 </li>
</ul>
</li>
<li><p>对 constructor 的影响</p>
<ul>
<li><p>由于这种方式是将子类原型修改成了一个新的对象，而这个新对象中是没有<code>constructor</code>属性的，所以需要手动为新对象添加<code>constructor</code>属性，并指向子类构造函数</p>
</li>
<li><p>添加方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1 直接添加（有一个弊端，就是constructor属性默认可枚举）</span><br><span class="line">A.prototype.constructor = A;</span><br><span class="line"></span><br><span class="line">// 2 使用Object的 defineProperty() 添加</span><br><span class="line">Object.defineProperty(A.prototype, &quot;constructor&quot;, &#123;</span><br><span class="line">	value: A,</span><br><span class="line">	enumerable: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="4-组合继承1（构造函数-原型链2）"><a href="#4-组合继承1（构造函数-原型链2）" class="headerlink" title="4 组合继承1（构造函数+原型链2）"></a>4 组合继承1（构造函数+原型链2）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = <span class="string">&#x27;nan&#x27;</span>;</span><br><span class="line">B.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">	B.call(<span class="built_in">this</span>, <span class="string">&#x27;小猫&#x27;</span>); <span class="comment">// 第一次调用</span></span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = <span class="keyword">new</span> B(<span class="string">&#x27;小狗&#x27;</span>); <span class="comment">// 第二次调用</span></span><br><span class="line">A.prototype.constructor = A;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>好处</p>
<ul>
<li><p>通过构造函数方式可以继承到父类的实例属性/方法</p>
</li>
<li><p>通过原型链方式可以继承到父类的原型属性/方法</p>
</li>
</ul>
</li>
<li><p>弊端</p>
<ul>
<li>父类的实例属性会在子类实例和子类原型上都定义一份，不过不影响，因为会先使用实例自己的属性</li>
<li>会调用两次父类构造函数</li>
<li>需要手动为新的子类原型对象添加 <code>constructor</code>属性</li>
</ul>
</li>
</ol>
<h3 id="5-组合继承2（构造函数-原型链1）"><a href="#5-组合继承2（构造函数-原型链1）" class="headerlink" title="5 组合继承2（构造函数+原型链1）"></a>5 组合继承2（构造函数+原型链1）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = <span class="string">&#x27;nan&#x27;</span>;</span><br><span class="line">B.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">	B.call(<span class="built_in">this</span>, <span class="string">&#x27;小猫&#x27;</span>); </span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.__proto__ = B.prototype</span><br></pre></td></tr></table></figure>

<ol>
<li><p>好处</p>
<ul>
<li><p>通过构造函数方式可以继承到父类的实例属性/方法</p>
</li>
<li><p>通过原型链方式可以继承到父类的原型属性/方法</p>
</li>
</ul>
</li>
<li><p>弊端</p>
<ul>
<li>虽然效果实现了，但这种方式概念有问题</li>
<li><code>A.prototype.__proto__ = B.prototype</code>，说明 A.prototype 是 由 B 创建的，但事实并不是</li>
</ul>
</li>
</ol>
<h3 id="6-最终方式"><a href="#6-最终方式" class="headerlink" title="6 最终方式"></a>6 最终方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.gender = <span class="string">&#x27;nan&#x27;</span>;</span><br><span class="line">B.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1 继承父类实例属性/方法</span></span><br><span class="line">	B.call(<span class="built_in">this</span>, <span class="string">&#x27;小猫&#x27;</span>); </span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 设置子类原型对象</span></span><br><span class="line">A.prototype = <span class="built_in">Object</span>.create(B.prototype);</span><br><span class="line"><span class="comment">// 3 为子类原型对象添加 constructor</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(A.prototype, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">	<span class="attr">value</span>: A,</span><br><span class="line">	<span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 4 继承父类静态属性/方法</span></span><br><span class="line">A.__proto__ = B</span><br></pre></td></tr></table></figure>

<h2 id="3-6-Mixin-模式"><a href="#3-6-Mixin-模式" class="headerlink" title="3.6 Mixin 模式"></a>3.6 Mixin 模式</h2><ol>
<li><p>JS 不支持多继承，也没有接口实现，如果要使用多个类的方法时可以使用 mixin 混合模式来完成</p>
</li>
<li><p>Mixin模式 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口</p>
</li>
<li><p>Mixin 可以看作是一个包含许多功能的对象，使用时将这些功能合并到要使用功能的对象原型上即可</p>
</li>
<li><p>例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixinRunner</span>(<span class="params">BaseClass</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">BaseCalss</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="title">running</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixinEater</span>(<span class="params">BaseClass</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">BaseCalss</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="title">eating</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NewStuClass = mixinEater(mixinRunner(Student));</span><br><span class="line"><span class="keyword">var</span> newSt = <span class="keyword">new</span> NewStuClass();</span><br><span class="line">newSt.running();</span><br><span class="line">newSt.eating();</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="四-Class"><a href="#四-Class" class="headerlink" title="四 Class"></a>四 Class</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li>class 只是语法糖，为了让类的声明与继承更加简洁清晰，底层实现机制依然是原型继承，与其它语言的 class 不一样</li>
<li>class 其实就是函数，<code>typeof 类 -&gt; function</code></li>
<li>class 内部代码始终以严格模式执行</li>
<li>class 不存在变量提升</li>
<li>class 中的属性名可以采用表达式<code>[]</code></li>
<li>class 中定义的属性都是实例属性，定义的方法都是原型方法且不可枚举</li>
</ol>
<h2 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2 语法"></a>4.2 语法</h2><h3 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1 定义类"></a>1 定义类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 类表达式</span></span><br><span class="line"><span class="keyword">let</span> 类名= <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用类 <code>new</code> 一个对象时会自动调用构造函数</li>
<li>构造函数如果省略，则会有默认构造函数</li>
<li><code>constructor</code> 默认返回实例对象（即 <code>this</code>），可以改为返回另一个对象</li>
<li>类的原型的 <code>constructor</code> 属性指向类本身：<code>类.prototype.constructor = 类</code></li>
</ol>
<h3 id="2-属性-amp-方法"><a href="#2-属性-amp-方法" class="headerlink" title="2 属性 &amp; 方法"></a>2 属性 &amp; 方法</h3><h4 id="1-实例属性"><a href="#1-实例属性" class="headerlink" title="1 实例属性"></a>1 实例属性</h4><ol>
<li><p>使用<code>this.</code> 定义在<code>constructor</code>中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">age</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在类中直接定义的属性就是实例属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	age = <span class="number">18</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-原型方法"><a href="#2-原型方法" class="headerlink" title="2 原型方法"></a>2 原型方法</h4><ol>
<li><p>在类的原型上定义方法，是可枚举的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在类中直接定义的方法就是原型方法，且不可枚举（non-enumerable）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">show</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-静态属性-方法"><a href="#3-静态属性-方法" class="headerlink" title="3 静态属性/方法"></a>3 静态属性/方法</h4><ol>
<li><p>定义在类上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User.age = <span class="number">10</span>;</span><br><span class="line">User.show() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>在类中定义的属性/方法前加<code>static</code>关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> age = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 静态方法可以包含 this 关键字，this 指的是类本身，而不是实例对象 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-私有属性-方法"><a href="#4-私有属性-方法" class="headerlink" title="4 私有属性 / 方法"></a>4 私有属性 / 方法</h4><ol>
<li><p>利用 Symbol</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const _name = Symbol();</span><br><span class="line">const _show = Symbol();</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this[_name] = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [_show]()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const _name = new WeakMap();</span><br><span class="line">const _show = new WeakMap();</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        _name.set(this, name);</span><br><span class="line">        _show.set(this, () =&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-访问器-getter-setter"><a href="#3-访问器-getter-setter" class="headerlink" title="3 访问器 getter/setter"></a>3 访问器 getter/setter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	_name;</span><br><span class="line">	get name()&#123;</span><br><span class="line">		return this._name;</span><br><span class="line">	&#125;</span><br><span class="line">	set name(value) &#123;</span><br><span class="line">		this._name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-class-的继承"><a href="#4-3-class-的继承" class="headerlink" title="4.3 class 的继承"></a>4.3 class 的继承</h2><h3 id="1-extends"><a href="#1-extends" class="headerlink" title="1 extends"></a>1 extends</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法和原型方法都可以继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 子类构造函数第一行必须先调用父类构造函数</span></span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-super"><a href="#2-super" class="headerlink" title="2 super"></a>2 super</h3><h4 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 子 父：在子类中调用父类方法</span></span><br><span class="line">子：<span class="built_in">this</span>.__proto__.__proto__</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 子 父 爷：在子类中调用父类方法，父类方法中又调用了父类的父类的方法</span></span><br><span class="line">子：<span class="built_in">this</span>.__proto__.__proto__</span><br><span class="line">父：<span class="built_in">this</span>.__proto__</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 父 爷：直接在父类中调用父类的父类的方法</span></span><br><span class="line">父：<span class="built_in">this</span>.__proto__.__proto__</span><br></pre></td></tr></table></figure>

<ul>
<li>如果只有双层继承，使用 <code>this </code>是可以的，如果有多重继承，同一个类中的代码不同情况是不一样的</li>
</ul>
<h4 id="2-用法"><a href="#2-用法" class="headerlink" title="2 用法"></a>2 用法</h4><ol>
<li><p>super 只能在类或对象的方法中使用，而不能在函数中使用</p>
</li>
<li><p>使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误，无法看出是函数还是对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">super</span>); </span><br></pre></td></tr></table></figure></li>
<li><p>调用父类构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 此时 super 代表父类的构造函数</span><br><span class="line">super([arguments]);</span><br></pre></td></tr></table></figure></li>
<li><p>调用父类方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 此时 super 代表父类原型对象，如果是静态方法则 super 代表父类本身</span><br><span class="line">super.functionOnParent([arguments]);</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/04-JS%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/04-JS%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">04-JS对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-14 19:56:53 / 修改时间：19:59:25" itemprop="dateCreated datePublished" datetime="2022-02-14T19:56:53+08:00">2022-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-创建对象的方式"><a href="#1-1-创建对象的方式" class="headerlink" title="1.1 创建对象的方式"></a>1.1 创建对象的方式</h2><h3 id="1-对象字面量"><a href="#1-对象字面量" class="headerlink" title="1 对象字面量"></a>1 对象字面量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 标准形式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">key</span>: value,</span><br><span class="line">	<span class="attr">key</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 属性的简写：Property Shorthand</span></span><br><span class="line"><span class="comment">// 如果属性名和属性值相同，可以简写</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;mm&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="comment">// 简写</span></span><br><span class="line">	name,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 方法的简写：Method Shorthand</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">key</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 简写</span></span><br><span class="line">	<span class="function"><span class="title">key</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 计算属性名：Computed Property Names</span></span><br><span class="line"><span class="comment">// 如果属性名是一个表达式，则使用[]包裹，意思是取表达式的值</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	[expr]: value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>对象字面量内部调用了 <code>Object</code> 的构造函数</li>
<li>对象字面量与 <code>json</code> 的区别<ol>
<li>属性<ul>
<li>JSON 属性只能是字符串，且必须加双引号</li>
<li>JS 对象属性可以是字符串和Symbol，可以省略引号（单/双）</li>
</ul>
</li>
<li>值<ul>
<li>JSON 值不能是函数和 <code>undefined</code></li>
<li>JS 对象值任意</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="2-Object-的-create-方法"><a href="#2-Object-的-create-方法" class="headerlink" title="2 Object 的 create 方法"></a>2 Object 的 <code>create</code> 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这种方式可以指定原型</span><br><span class="line">Object.create(proto[, propertiesObject])</span><br></pre></td></tr></table></figure>

<h3 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3 构造函数"></a>3 构造函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 1 内置构造函数</span><br><span class="line">new Object([value])</span><br><span class="line">new Array()</span><br><span class="line">new Function()</span><br><span class="line">new String()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 2 自定义构造函数</span><br><span class="line">// 2.1 定义构造函数，构造函数名首字母大写</span><br><span class="line">function 构造函数名(形参列表) &#123;</span><br><span class="line">	this.属性 = 值;</span><br><span class="line">	this.方法 = function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.2 使用自定义构造创建对象</span><br><span class="line">new 构造函数名(实参列表);</span><br></pre></td></tr></table></figure>

<ol>
<li>在其他面向对象的编程语言里面，构造函数是存在于类中的一个方法，称之为构造方法，而在 js 中，构造函数就是一个普通的函数</li>
<li>js 中普通函数和构造函数的区别：<ol>
<li>调用方式不同；一个普通的函数被 new 操作符调用，那么这个函数就称为一个构造函数</li>
<li>通常为了区分普通函数和构造函数，会将构造函数首字母大写</li>
</ol>
</li>
<li>如果一个函数被 new 操作符调用<ol>
<li>在内存中创建一个新的对象（空对象）</li>
<li>这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性</li>
<li>构造函数内部的this，会指向创建出来的新对象</li>
<li>执行函数的内部代码（函数体代码）</li>
<li>如果构造函数没有返回非空对象，则返回创建出来的新对象</li>
</ol>
</li>
<li>构造函数的缺点：构造函数中定义的函数是每一个对象的方法，会在每个对象中都存在一份</li>
</ol>
<h3 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4 工厂模式"></a>4 工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userFactory</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">	<span class="comment">// 1</span></span><br><span class="line">	obj.name = name;</span><br><span class="line">	obj.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 2 简写</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		name,</span><br><span class="line">		<span class="function"><span class="title">show</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>工厂函数是函数调用，自定义构造函数是 <code>new</code></li>
<li>工厂函数是函数名称小写，自定义构造函数名称通常大写</li>
<li>工厂函数内部需要显式创建一个对象，然后根据参数赋值后再显式返回</li>
<li>自定义构造函数根据参数自动创建一个对象并返回</li>
<li>工厂模式：缺点是不能获取对象的具体类型</li>
</ol>
<h2 id="1-2-对象的属性"><a href="#1-2-对象的属性" class="headerlink" title="1.2 对象的属性"></a>1.2 对象的属性</h2><h3 id="1-属性描述符"><a href="#1-属性描述符" class="headerlink" title="1 属性描述符"></a>1 属性描述符</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><code>property descriptor</code></li>
<li>JS 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为属性描述符</li>
<li>元属性：属性描述符中的属性，用来描述对象属性的元信息，即描述对象属性的属性<ol>
<li>value<ul>
<li>该属性的值</li>
<li>默认为 undefined</li>
</ul>
</li>
<li>writable<ul>
<li>该属性的 value 是否可修改</li>
<li>直接在一个对象上定义某个属性时，writable 默认为 true</li>
<li>通过属性描述符定义一个属性时，writable 默认为 false</li>
</ul>
</li>
<li>configurable<ul>
<li>该属性是否可通过 delete 删除；该属性的属性描述符是否可修改</li>
<li>直接在一个对象上定义某个属性时，configurable 默认为 true</li>
<li>通过属性描述符定义一个属性时，configurable 默认为 false</li>
</ul>
</li>
<li>enumerable<ul>
<li>该属性是否可枚举</li>
<li>直接在一个对象上定义某个属性时，enumerable 默认为 true</li>
<li>通过属性描述符定义一个属性时，enumerable 默认为 false</li>
</ul>
</li>
<li>get<ul>
<li>获取属性时会执行的函数</li>
<li>默认为 undefined</li>
</ul>
</li>
<li>set<ul>
<li>设置属性时会执行的函数</li>
<li>默认为 undefined</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h4><table>
<thead>
<tr>
<th>分类</th>
<th>可以具有的元属性</th>
</tr>
</thead>
<tbody><tr>
<td>数据描述符</td>
<td><code>configurable enumerable value writable</code></td>
</tr>
<tr>
<td>存取描述符</td>
<td><code>configurable enumerable get set</code></td>
</tr>
</tbody></table>
<ul>
<li>一个对象只能取其中一类属性描述符</li>
</ul>
<h3 id="2-属性管理"><a href="#2-属性管理" class="headerlink" title="2 属性管理"></a>2 属性管理</h3><h4 id="1-读写"><a href="#1-读写" class="headerlink" title="1 读写"></a>1 读写</h4><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>obj.property</code></td>
<td>必须是确定的属性名，且名称不特殊（数字、空格…）</td>
</tr>
<tr>
<td><code>obj[&#39;property&#39;]</code></td>
<td>属性名可以是表达式和变量，或者名称比较特殊</td>
</tr>
</tbody></table>
<h4 id="2-判断"><a href="#2-判断" class="headerlink" title="2 判断"></a>2 判断</h4><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>prop in obj</code></td>
<td>对象或其原型链上是否有指定属性</td>
</tr>
</tbody></table>
<h4 id="3-删除"><a href="#3-删除" class="headerlink" title="3 删除"></a>3 删除</h4><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>delete object.property</code></td>
<td>删除属性，所有情况都返回 <code>true</code></td>
</tr>
<tr>
<td><code>delete object[&#39;property&#39;]</code></td>
<td>删除属性，所有情况都返回 <code>true</code></td>
</tr>
</tbody></table>
<h4 id="4-迭代"><a href="#4-迭代" class="headerlink" title="4 迭代"></a>4 迭代</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object)&#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历对象（推荐）<ol>
<li>遍历对象的所有可枚举属性（包括它的原型链上的可枚举属性）</li>
<li>每次循环获取的是键（属性名）</li>
</ol>
</li>
<li>遍历数组（不推荐）<ol>
<li>数组键名是数字，但每次循环获取的是索引的字符串</li>
<li>除了遍历数组元素外，数组本身以及原型链上的可枚举属性也会被遍历到</li>
<li>某些情况下，不能保证按顺序返回索引</li>
</ol>
</li>
</ol>
<h4 id="5-访问器（getter-setter）"><a href="#5-访问器（getter-setter）" class="headerlink" title="5 访问器（getter/setter）"></a>5 访问器（getter/setter）</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h5><ol>
<li>JS 中 <code>getter/setter</code> 的调用是当成属性来访问，自动调用方法</li>
<li>调用方式与属性访问方式一样<ol>
<li><code>obj.访问器名</code></li>
<li><code>obj[&#39;访问器名&#39;]</code></li>
</ol>
</li>
<li>访问器名称可以是一个有效标识符或一个表达式</li>
</ol>
<h5 id="2-定义方式"><a href="#2-定义方式" class="headerlink" title="2 定义方式"></a>2 定义方式</h5><ol>
<li><p>通过配置属性描述符的元属性定义访问器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">_name</span> : <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> obj._name;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">		obj._name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.name; <span class="comment">// 调用get取值</span></span><br><span class="line">obj.name = <span class="string">&#x27;旺财&#x27;</span>; <span class="comment">// 调用set设置值</span></span><br></pre></td></tr></table></figure></li>
<li><p>对象字面量中直接定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">_name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">	<span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>._name = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="二-Object"><a href="#二-Object" class="headerlink" title="二 Object"></a>二 Object</h1><h2 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h2><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Object([value])</code></td>
<td>构造函数</td>
<td>创建一个对象</td>
</tr>
<tr>
<td><code>Object([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个对象</td>
</tr>
</tbody></table>
<ul>
<li><code>value</code> ：<ol>
<li>为空或者是 <code>undefined null</code>，返回一个空对象</li>
<li>是基本类型的值则返回其包装对象</li>
<li>是引用类型则直接返回</li>
</ol>
</li>
</ul>
<h2 id="2-2-静态方法"><a href="#2-2-静态方法" class="headerlink" title="2.2 静态方法"></a>2.2 静态方法</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1 属性"></a>1 属性</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.keys(obj)</code></td>
<td>返回对象自身可枚举属性的键的数组</td>
</tr>
<tr>
<td><code>Object.values(obj)</code></td>
<td>返回对象自身可枚举属性的值的数组</td>
</tr>
<tr>
<td><code>Object.entries(obj)</code></td>
<td>返回对象自身可枚举属性的键值对的数组</td>
</tr>
<tr>
<td><code>Object.getOwnPropertyNames(obj)</code></td>
<td>返回对象自身的所有属性（包含可枚举和不可枚举属性，不包含 <code>Symbol</code> 属性）的键的数组</td>
</tr>
<tr>
<td><code>Object.getOwnPropertySymbols(obj)</code></td>
<td>返回对象自身的所有 <code>Symbol</code> 属性的数组</td>
</tr>
</tbody></table>
<h3 id="2-属性描述符"><a href="#2-属性描述符" class="headerlink" title="2 属性描述符"></a>2 属性描述符</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.getOwnPropertyDescriptor(obj, prop)</code></td>
<td>获取对象自身某个属性的属性描述符</td>
</tr>
<tr>
<td><code>Object.getOwnPropertyDescriptors(obj)</code></td>
<td>获取对象自身所有属性的属性描述符</td>
</tr>
<tr>
<td><code>Object.defineProperty(obj, prop, descriptor)</code></td>
<td>如果对象自身存在指定属性，则修改它的属性描述符，否则为对象添加指定属性并定义属性描述符，返回该对象</td>
</tr>
<tr>
<td><code>Object.defineProperties(obj, props)</code></td>
<td>修改或添加对象多个属性的属性描述对象，返回该对象</td>
</tr>
</tbody></table>
<h3 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3 创建对象"></a>3 创建对象</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.create(proto[, propertiesObject])</code></td>
<td>根据原型对象和属性（使用属性描述符定义），创建一个新的对象</td>
</tr>
<tr>
<td><code>Object.fromEntries(iterable)</code></td>
<td>将一个 entries 转换成对象，是 <code>Object.entries()</code> 的反转</td>
</tr>
<tr>
<td><code>Object.assign(target, ...sources)</code></td>
<td>将 n 个源对象的所有可枚举属性复制到目标对象，并返回目标对象</td>
</tr>
</tbody></table>
<ul>
<li><code>Object.assign(target, ...sources)</code><ol>
<li>如果目标对象与源对象有同名属性，或多个源对象有同名属性，后边覆盖前边</li>
<li><code>Object.assign</code> 方法实行的是浅拷贝</li>
<li>数组会被当作对象，即相同索引会覆盖</li>
<li>如果属性值是取值函数，会计算后再复制</li>
</ol>
</li>
</ul>
<h3 id="4-原型对象"><a href="#4-原型对象" class="headerlink" title="4 原型对象"></a>4 原型对象</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.getPrototypeOf(obj)</code></td>
<td>获取对象的原型对象，即<code>obj.__proto__</code></td>
</tr>
<tr>
<td><code>Object.setPrototypeOf(obj, prototype)</code></td>
<td>获取对象的原型对象</td>
</tr>
</tbody></table>
<h3 id="5-比较"><a href="#5-比较" class="headerlink" title="5 比较"></a>5 比较</h3><ul>
<li><code>Object.is(value1, value2)</code><ul>
<li>判断两个值是否相等，不会作类型转换</li>
<li>与<code>===</code>的区别<ol>
<li><code>===</code> 认为<code>-0</code>和<code>+0</code>相等，此方法认为不相等</li>
<li><code>===</code> 认为<code>NaN</code>和<code>NaN</code>不相等，此方法认为相等</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="6-状态"><a href="#6-状态" class="headerlink" title="6 状态"></a>6 状态</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.preventExtensions(obj)</code></td>
<td>让一个对象变的不可扩展，即永远不能添加新的属性</td>
</tr>
<tr>
<td><code>Object.isExtensible(obj)</code></td>
<td>判断一个对象是否可扩展</td>
</tr>
<tr>
<td><code>Object.seal(obj)</code></td>
<td>封闭一个对象，此对象不可扩展且对象所有自身属性的<code>configurable</code>标记为 <code>false</code>，即不能添加、删除属性，属性修饰符不可配置</td>
</tr>
<tr>
<td><code>Object.isSealed(obj)</code></td>
<td>判断一个对象是否被封闭</td>
</tr>
<tr>
<td><code>Object.freeze(obj)</code></td>
<td>冻结一个对象，此对象不可扩展且对象所有自身属性 <code>writable configurable</code> 标记为 <code>false</code>，即不能添加、修改和删除属性，属性修饰符不可配置</td>
</tr>
<tr>
<td><code>Object.isFrozen(obj)</code></td>
<td>判断一个对象是否被冻结</td>
</tr>
</tbody></table>
<h2 id="4-3-原型方法-Object-prototype"><a href="#4-3-原型方法-Object-prototype" class="headerlink" title="4.3 原型方法 Object.prototype."></a>4.3 原型方法 <code>Object.prototype.</code></h2><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>默认返回 <code>[object type]</code>，通常会覆盖</td>
</tr>
<tr>
<td><code>toLocaleString()</code></td>
<td>默认返回 <code>toString()</code> 的结果，可以覆盖</td>
</tr>
<tr>
<td><code>hasOwnProperty(prop)</code></td>
<td>判断对象自身是否含有某个属性</td>
</tr>
<tr>
<td><code>propertyIsEnumerable(prop)</code></td>
<td>判断某个属性是否可枚举</td>
</tr>
<tr>
<td><code>isPrototypeOf(object)</code></td>
<td>判断调用对象是否在传入对象的原型链上</td>
</tr>
<tr>
<td><code>valueOf()</code></td>
<td>返回对象原始值，若没有原始值，返回对象本身，通常会覆盖</td>
</tr>
</tbody></table>
<ol>
<li><p><code>isPrototypeOf(object)</code> 和 <code>instanceof</code> 的区别</p>
<ol>
<li><code>A instanceof B</code> ：判断 <code>B.prototype</code>是否在 <code>A</code> 的原型链上</li>
<li><code>B.isPrototypeOf(A)</code>：判断 <code>B</code> 是否在 <code>A</code> 的原型链上</li>
</ol>
</li>
<li><p><code>valueOf()</code> 返回值</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number</code></td>
<td>数值</td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td>布尔值</td>
</tr>
<tr>
<td><code>String</code></td>
<td>字符串值</td>
</tr>
<tr>
<td><code>Object</code></td>
<td>对象本身</td>
</tr>
<tr>
<td><code>Array</code></td>
<td>数组本身</td>
</tr>
<tr>
<td><code>Function</code></td>
<td>函数本身</td>
</tr>
<tr>
<td><code>Date</code></td>
<td>距离1970-01-01 00:00:00 的毫秒数</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="三-展开语法（Spread-syntax）"><a href="#三-展开语法（Spread-syntax）" class="headerlink" title="三 展开语法（Spread syntax）"></a>三 展开语法（Spread syntax）</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ol>
<li><p>展开语法用  <code>...</code> 表示    </p>
<ol>
<li>在函数调用或构造字面量数组时, 将<strong>可迭代对象</strong>在语法层面展开</li>
<li>在构造字面量对象时, 将对象按 <code>key:value</code> 的方式展开</li>
</ol>
</li>
<li><p>展开语法其实是一个浅拷贝</p>
</li>
</ol>
<h2 id="3-2-应用"><a href="#3-2-应用" class="headerlink" title="3.2 应用"></a>3.2 应用</h2><ol>
<li><p>函数调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function show(x, y, z) &#123;&#125;</span><br><span class="line">let args = [0, 1, 2];</span><br><span class="line">show(...args); // 等价于 show(0, 1, 2)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构造字面量数组</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [0, 1, 2];</span><br><span class="line">let arr2 = [3, 4, 5];</span><br><span class="line">let arr3 = [...arr1, ...arr2]; // [0,1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>构造字面量对象</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; foo: &#x27;bar&#x27;, x: 42 &#125;;</span><br><span class="line">let obj2 = &#123; foo: &#x27;baz&#x27;, y: 13 &#125;;</span><br><span class="line">let clonedObj = &#123; ...obj1 &#125;; // 克隆后的对象: &#123; foo: &quot;bar&quot;, x: 42 &#125;</span><br><span class="line">let mergedObj = &#123; ...obj1, ...obj2 &#125;; // 合并后的对象: &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="四-解构赋值"><a href="#四-解构赋值" class="headerlink" title="四 解构赋值"></a>四 解构赋值</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ol>
<li> ES6 中新增了一个从数组或对象中方便获取数据的方法，称之为解构 Destructuring</li>
<li> 解构赋值：从数组和对象中提取值，对变量进行赋值</li>
<li> 解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）</li>
</ol>
<h2 id="4-2-应用"><a href="#4-2-应用" class="headerlink" title="4.2 应用"></a>4.2 应用</h2><h3 id="1-解构数组"><a href="#1-解构数组" class="headerlink" title="1 解构数组"></a>1 解构数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 先声明后赋值的解构</span></span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line">[a, b] = [<span class="number">10</span>, <span class="number">20</span>]; <span class="comment">// a=10 b=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 声明并赋值的解构</span></span><br><span class="line"><span class="keyword">let</span> [a,b] = [<span class="number">10</span>, <span class="number">20</span>]; <span class="comment">// a=10 b=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 有默认值的解构</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = <span class="number">4</span>] = [<span class="number">1</span>]; <span class="comment">// a=1 b=4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 变量数量小于数组值数量时，忽略多余值</span></span><br><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// a=1 b=2</span></span><br><span class="line"><span class="keyword">let</span> [, ,a,b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">// a=3 b=4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 可用于交换变量</span></span><br><span class="line"><span class="keyword">let</span> a =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a]; <span class="comment">// a=2 b=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 剩余参数</span></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// a=1 b=[2,3]</span></span><br></pre></td></tr></table></figure>

<h3 id="3-解构对象"><a href="#3-解构对象" class="headerlink" title="3 解构对象"></a>3 解构对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 基本语法</span></span><br><span class="line"><span class="keyword">let</span> &#123;key&#125; = &#123;<span class="attr">key</span>:value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 重命名属性</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">key</span>:newKey&#125; = &#123;<span class="attr">key</span>:value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 先声明后赋值的解构</span></span><br><span class="line"><span class="keyword">let</span> name, age;</span><br><span class="line"><span class="comment">// 错误： 赋值时必须使用 `()` 包括，因为左边`&#123;name, age&#125;`会被认为是块而不是对象字面量</span></span><br><span class="line">&#123;name,age&#125; =  &#123;<span class="attr">name</span>:<span class="string">&#x27;an3&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;); </span><br><span class="line"><span class="comment">// 正确：name=&#x27;an3&#x27; age=18</span></span><br><span class="line">(&#123;name, age&#125; = &#123;<span class="attr">name</span>:<span class="string">&#x27;an3&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 有默认值的解构</span></span><br><span class="line"><span class="keyword">let</span> &#123;name=<span class="string">&#x27;haha&#x27;</span>, age=<span class="number">10</span>&#125; = &#123;<span class="attr">name</span>:<span class="string">&#x27;an3&#x27;</span>&#125;; <span class="comment">// name=&#x27;an3&#x27; age=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 变量数量小于对象键值对数量时，忽略多余值</span></span><br><span class="line"><span class="keyword">let</span> &#123;name=<span class="string">&#x27;haha&#x27;</span>, age=<span class="number">10</span>&#125; = &#123;<span class="attr">name</span>:<span class="string">&#x27;an3&#x27;</span>,<span class="attr">age</span>:<span class="number">10</span>,<span class="attr">sex</span>:<span class="number">1</span>&#125;; <span class="comment">// name=&#x27;an3&#x27; age=18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 解构嵌套</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">	<span class="attr">lesson</span>:&#123;</span><br><span class="line">		<span class="attr">title</span>:<span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">		<span class="attr">score</span>:<span class="number">90</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name,<span class="attr">lesson</span>:&#123;title,score&#125;&#125; = user;</span><br></pre></td></tr></table></figure>

<h1 id="五-对象拷贝"><a href="#五-对象拷贝" class="headerlink" title="五 对象拷贝"></a>五 对象拷贝</h1><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><ol>
<li><p>浅拷贝</p>
<ul>
<li>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 </li>
<li>一个对象修改可能会影响到另一个对象</li>
</ul>
</li>
<li><p>深拷贝</p>
<ul>
<li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象</li>
<li>一个对象修改不会影响到另一个对象</li>
</ul>
</li>
</ol>
<h2 id="5-2-浅拷贝方式"><a href="#5-2-浅拷贝方式" class="headerlink" title="5.2 浅拷贝方式"></a>5.2 浅拷贝方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 1 创建新对象，然后使用`for...in`遍历原对象属性并连同值一起添加到新对象上</span><br><span class="line">let source = &#123;name:&#x27;an3&#x27;, age:18&#125;;</span><br><span class="line">let cp = &#123;&#125;;</span><br><span class="line">for (const key in source)&#123;</span><br><span class="line">	if(source.hasOwnProperty(key)&#123;</span><br><span class="line">		cp[key] = source[key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2 Object.assign(target, ...sources)：将目标对象设为空对象，就相当于返回了原对象的浅拷贝</span><br><span class="line">let source = &#123;name:&#x27;an3&#x27;, age:18&#125;;</span><br><span class="line">let cp = Object.assign(&#123;&#125;, source);</span><br><span class="line"></span><br><span class="line">// 3 展开语法</span><br><span class="line">let source = &#123;name:&#x27;an3&#x27;, age:18&#125;;</span><br><span class="line">let cp = &#123;...source&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-深拷贝方式"><a href="#5-3-深拷贝方式" class="headerlink" title="5.3 深拷贝方式"></a>5.3 深拷贝方式</h2><h3 id="1-JSON"><a href="#1-JSON" class="headerlink" title="1 JSON"></a>1 JSON</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br><span class="line">const jsonString = JSON.stringify(obj);</span><br><span class="line">const objCopy = JSON.parse(jsonString)</span><br></pre></td></tr></table></figure>

<ol>
<li>对象属性的值中如果有 <code>函数、undefined、symbol</code> 则经过 <code>JSON.stringify()</code> 序列化后的 <code>JSON</code> 字符串中这个键值对会消失，也就无法拷贝</li>
<li>无法拷贝不可枚举的属性，无法拷贝对象的原型链</li>
<li>拷贝 <code>Date</code> 引用类型会变成字符串</li>
<li>拷贝 <code>RegExp</code> 引用类型会变成空对象</li>
<li>对象中含有 <code>NaN、Infinity、-Infinity</code> ，则序列化的结果会变成 <code>null</code></li>
<li>无法拷贝对象的循环应用，即 <code>obj[key] = obj</code></li>
</ol>
<h3 id="2-递归"><a href="#2-递归" class="headerlink" title="2 递归"></a>2 递归</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理：浅拷贝只拷贝一层，利用递归，如果这一层属性的值是引用类型，就再拷贝一层 ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 对象的属性值有可能是数组，判断一下防止递归时把数组变成了对象</span></span><br><span class="line">	<span class="keyword">let</span> cpObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">	<span class="comment">// Object.entries()方法对于对象和数组返回结果形式是一样的</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">const</span> [k, v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">		<span class="comment">// 判断对象属性如果是引用类型就递归拷贝</span></span><br><span class="line">		cpObj[k] = <span class="keyword">typeof</span> v == <span class="string">&#x27;object&#x27;</span> ? deepCopy(v) : v;</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> cpObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="六-内置对象"><a href="#六-内置对象" class="headerlink" title="六 内置对象"></a>六 内置对象</h1><h2 id="6-1-Math"><a href="#6-1-Math" class="headerlink" title="6.1 Math"></a>6.1 Math</h2><h3 id="1-静态属性"><a href="#1-静态属性" class="headerlink" title="1 静态属性"></a>1 静态属性</h3><table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Math.E</code></td>
<td>欧拉常数 <code>e</code></td>
</tr>
<tr>
<td><code>Math.PI</code></td>
<td><code>π</code></td>
</tr>
</tbody></table>
<h3 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Math.abs(x)</code></td>
<td>绝对值</td>
</tr>
<tr>
<td><code>Math.ceil(x)</code></td>
<td>向上取整</td>
</tr>
<tr>
<td><code>Math.floor(x) </code></td>
<td>向下取整</td>
</tr>
<tr>
<td><code>Math.pow(x, y)</code></td>
<td>返回 x 的 y 次幂</td>
</tr>
<tr>
<td><code>Math.random()</code></td>
<td>返回 <code>[0-1) </code>之间的伪随机数</td>
</tr>
<tr>
<td><code>Math.round(x)</code></td>
<td>四舍五入</td>
</tr>
<tr>
<td><code>Math.sqrt(x)</code></td>
<td>平方</td>
</tr>
<tr>
<td><code>Math.log(x)</code></td>
<td>对数</td>
</tr>
<tr>
<td><code>Math.exp(x)</code></td>
<td><code>e</code> 的指数，即 e<sup>x</sup></td>
</tr>
<tr>
<td><code>Math.min([value1[,value2, ...]])</code></td>
<td>返回一组数字中的最小值。如果有任一参数不能转换为数值，则返回 <code>NaN</code></td>
</tr>
<tr>
<td><code>Math.max(value1[,value2, ...]) </code></td>
<td>返回一组数字中的最大值。如果有任一参数不能转换为数值，则返回 <code>NaN</code></td>
</tr>
<tr>
<td><code>Math.sin(x)</code></td>
<td>正弦</td>
</tr>
<tr>
<td><code>Math.cos(x)</code></td>
<td>余弦</td>
</tr>
<tr>
<td><code>Math.tan(x)</code></td>
<td>正切</td>
</tr>
</tbody></table>
<h2 id="6-2-Date"><a href="#6-2-Date" class="headerlink" title="6.2 Date"></a>6.2 Date</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date([value])</code></td>
<td>普通函数</td>
<td>无论有没有参数，都返回当前日期和时间的字符串</td>
</tr>
<tr>
<td><code>new Date()</code></td>
<td>构造函数</td>
<td>创建一个当前日期和时间的 <code>Date</code> 对象</td>
</tr>
<tr>
<td><code>new Date(stamp)</code></td>
<td>构造函数</td>
<td>创建一个指定时间戳的 <code>Date</code> 对象</td>
</tr>
<tr>
<td><code>new Date(dateString)</code></td>
<td>构造函数</td>
<td>创建一个 <code>Date</code> 对象，时间由 <code>dateString</code> 决定，该字符串能被 <code>Date.parse() </code>正确识别</td>
</tr>
</tbody></table>
<h3 id="2-静态方法-1"><a href="#2-静态方法-1" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date.now()</code></td>
<td>返回当前时间距离时间零点的毫秒数</td>
</tr>
<tr>
<td><code>Date.parse(dateString)</code></td>
<td>解析日期字符串，返回该时间距离时间零点的毫秒数</td>
</tr>
</tbody></table>
<h3 id="3-原型方法-Date-prototype"><a href="#3-原型方法-Date-prototype" class="headerlink" title="3 原型方法 Date.prototype."></a>3 原型方法 <code>Date.prototype.</code></h3><h4 id="1-to"><a href="#1-to" class="headerlink" title="1 to"></a>1 to</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>返回日期时间字符串字符串</td>
</tr>
<tr>
<td><code>toLocaleString()</code></td>
<td>返回本地日期时间字符串</td>
</tr>
<tr>
<td><code>toUTCString()</code></td>
<td>返回 UTC 日期时间字符串</td>
</tr>
<tr>
<td><code>toISOString()</code></td>
<td>返回 ISO8601 写法的日期时间字符串，通常用于网络服务</td>
</tr>
<tr>
<td><code>toJSON()</code></td>
<td>与<code>toISOString()</code>方法的返回结果完全相同</td>
</tr>
</tbody></table>
<h4 id="2-get"><a href="#2-get" class="headerlink" title="2 get"></a>2 get</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getTime</code></td>
<td>返回距离事件元点的毫秒数</td>
</tr>
<tr>
<td><code>getFullYear</code></td>
<td>年（四位数）</td>
</tr>
<tr>
<td><code>getMonth()</code></td>
<td>月 <code>0-11</code></td>
</tr>
<tr>
<td><code>getDate()</code></td>
<td>日 <code>1-31</code></td>
</tr>
<tr>
<td><code>getDay()</code></td>
<td>星期 <code>0-6</code></td>
</tr>
<tr>
<td><code>getHours()</code></td>
<td>时 <code>0-23</code></td>
</tr>
<tr>
<td><code>getMinutes()</code></td>
<td>分 <code>0-59</code></td>
</tr>
<tr>
<td><code>getSeconds()</code></td>
<td>秒 <code>0-59</code></td>
</tr>
<tr>
<td><code>getMilliseconds()</code></td>
<td>毫秒 <code>0-999</code></td>
</tr>
</tbody></table>
<h4 id="3-set"><a href="#3-set" class="headerlink" title="3 set"></a>3 set</h4><ul>
<li>set 与 get 一一相对应，除了没有 <code>setDay()</code>，因为星期是算的</li>
</ul>
<h2 id="6-3-RegExp"><a href="#6-3-RegExp" class="headerlink" title="6.3 RegExp"></a>6.3 RegExp</h2><h3 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new RegExp(pattern [, flags])</code></td>
<td>创建 <code>RegExp</code> 对象，<code>flags</code>：可以是<code>g i m u y s</code>的任意组合</td>
</tr>
<tr>
<td><code>RegExp()</code></td>
<td>同 <code>new RegExp()</code></td>
</tr>
</tbody></table>
<h3 id="2-字面量"><a href="#2-字面量" class="headerlink" title="2 字面量"></a>2 字面量</h3><ul>
<li><code>/pattern/flags</code><ul>
<li><code>/</code> 斜杠表示开始和结束</li>
</ul>
</li>
</ul>
<h3 id="3-原型属性-RegExp-prototype"><a href="#3-原型属性-RegExp-prototype" class="headerlink" title="3 原型属性 RegExp.prototype."></a>3 原型属性 <code>RegExp.prototype.</code></h3><table>
<thead>
<tr>
<th>原型属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>global</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>g</code></td>
</tr>
<tr>
<td><code>ignoreCase</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>i</code></td>
</tr>
<tr>
<td><code>multiline</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>m</code></td>
</tr>
<tr>
<td><code>unicode</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>y</code></td>
</tr>
<tr>
<td><code>sticky</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>y</code></td>
</tr>
<tr>
<td><code>dotAll</code></td>
<td>只读</td>
<td>返回一个布尔值，判断是否设置了修饰符<code>s</code></td>
</tr>
<tr>
<td><code>flags</code></td>
<td>只读</td>
<td>返回一个字符串，包含已经设置的所有修饰符，按字母排序</td>
</tr>
<tr>
<td><code>source</code></td>
<td>只读</td>
<td>返回正则表达式文本字符串，该字符串不包含正则字面量两边的斜杠以及任何的标志字符</td>
</tr>
<tr>
<td><code>lastIndex</code></td>
<td>读写</td>
<td>指定下一次匹配的起始索引。正则表达式必须有 <code>g</code></td>
</tr>
</tbody></table>
<h3 id="4-原型方法-RegExp-prototype"><a href="#4-原型方法-RegExp-prototype" class="headerlink" title="4 原型方法 RegExp.prototype."></a>4 原型方法 <code>RegExp.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>test(str)</code></td>
<td>判断是否匹配，会更新正则对象的 <code>lastIndex</code> 属性</td>
</tr>
<tr>
<td><code>exec(str)</code></td>
<td>返回一个包含匹配项的数组（包含附加属性），若匹配失败返回 <code>null</code>，并将 <code>lastIndex</code> 重置为 0</td>
</tr>
</tbody></table>
<h2 id="6-4-JSON"><a href="#6-4-JSON" class="headerlink" title="6.4 JSON"></a>6.4 JSON</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1 语法"></a>1 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1 简单值：数字、字符串、布尔、null</span><br><span class="line">value</span><br><span class="line"></span><br><span class="line">// 2 对象：键必须用双引号 &quot;&quot; 包裹，值（简单值、对象、数组）</span><br><span class="line">&#123;</span><br><span class="line">	&quot;key&quot;: value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 3 数组：数组元素（简单值、对象、数组）</span><br><span class="line">[</span><br><span class="line">	value,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;key&quot;: value</span><br><span class="line">    &#125;,</span><br><span class="line">    []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="2-静态方法-2"><a href="#2-静态方法-2" class="headerlink" title="2 静态方法"></a>2 静态方法</h3><h4 id="1-JSON-stringify"><a href="#1-JSON-stringify" class="headerlink" title="1 JSON.stringify"></a>1 JSON.stringify</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(value[, replacer [, space]])</span><br></pre></td></tr></table></figure>

<ol>
<li>序列化：将对象转为字符串，该字符串符合 JSON 格式，并且可以被JSON.parse 方法还原</li>
<li>参数<ol>
<li>value：要被序列化的对象，如果对象有自定义的 <code>toJSON</code> 方法，会直接使用 <code>toJSON</code> 方法的结果</li>
<li>replacer<ul>
<li>如果是一个函数 <code>(key, value) =&gt; &#123;return newValue&#125;</code>，则在序列化过程中，被序列化的对象的每个属性都会经过该函数的处理</li>
<li>如果是一个数组，则只有包含在这个数组中的属性才会被序列化到最终的 JSON 字符串中</li>
</ul>
</li>
<li>space<ul>
<li>指定缩进用的空白字符串，用于美化输出（pretty-print）增加可读性。</li>
<li>可以是数字或字符串（不超过 10），会将每个键值对换行，并在前边添加相应的空格数或字符串</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="2-JSON-parse"><a href="#2-JSON-parse" class="headerlink" title="2 JSON.parse"></a>2 JSON.parse</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(text[, reviver])</span><br></pre></td></tr></table></figure>

<ol>
<li>反序列化：将 JSON 字符串转换成对应的对象</li>
<li>参数：<ol>
<li>text：JSON 字符串</li>
<li>reviver<ol>
<li>转换器，此函数调用时机在 parse 函数返回之前，用于在返回之前对所得到的对象执行操作</li>
<li>转成的对象的所有属性都会调用 reviver 函数，并且会将 reviver 返回值作为新值，如果 reviver 返回 <code>undefined</code>，会删除当前属性</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="6-5-集合"><a href="#6-5-集合" class="headerlink" title="6.5 集合"></a>6.5 集合</h2><h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1 Set"></a>1 Set</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>Set 中的元素有序（存取顺序一致） 唯一</li>
<li>可以存储基本数据类型和引用数据类型（包括 <code>NaN undefined null</code>）</li>
<li>判断元素相等： 基于 <code>sameValueZero</code> 算法<ul>
<li>类似 <code>===</code>，除了 NaN，<code>NaN === NaN</code> 返回 <code>false</code>，但是在 Set 中看作相等</li>
</ul>
</li>
<li>set 是可迭代对象，支持 for…of</li>
</ol>
<h4 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h4><ul>
<li><code>new Set([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，它的所有元素将不重复地被添加到 Set 中。</li>
<li>如果省略或其值为 <code>null</code>，则新的 Set 为空</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-原型属性-Set-prototype"><a href="#3-原型属性-Set-prototype" class="headerlink" title="3 原型属性 Set.prototype."></a>3 原型属性 <code>Set.prototype.</code></h4><table>
<thead>
<tr>
<th>原型属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>Set 集合的元素个数</td>
</tr>
</tbody></table>
<h4 id="4-原型方法-Set-prototype"><a href="#4-原型方法-Set-prototype" class="headerlink" title="4 原型方法 Set.prototype."></a>4 原型方法 <code>Set.prototype.</code></h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>add(value)</code></td>
<td>向 Set 末尾添加元素，返回 Set</td>
</tr>
<tr>
<td><code>delete(value)</code></td>
<td>从 Set 中删除指定元素，成功删除返回 true，否则返回 false</td>
</tr>
<tr>
<td><code>has(value)</code></td>
<td>判断 Set 中是否有指定的元素</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空 Set</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>由于 Set 结构没有键只有值，<code>keys()</code> 与 <code>values() </code> 完全一样</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>返回值的迭代器对象，值就是 Set 元素</td>
</tr>
<tr>
<td><code>entries()</code></td>
<td>返回键值对的迭代器对象，键值对形式为<code>[value, value]</code>，Set 中的元素即是键也是值</td>
</tr>
<tr>
<td><code>forEach(callback[, thisArg])</code></td>
<td>遍历 Set，按插入顺序依次执行回调函数</td>
</tr>
</tbody></table>
<ul>
<li><code>callback([currentValue[, currentKey[, set]]])</code><ul>
<li><code>currentValue</code><ul>
<li>当前元素</li>
</ul>
</li>
<li><code>currentKey</code><ul>
<li>由于 Set 没有键，<code>currentKey</code> 与 <code>currentValue</code> 永远都一样，也是当前元素</li>
</ul>
</li>
<li><code>set</code><ul>
<li>当前Set</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-Set-↔-数组"><a href="#5-Set-↔-数组" class="headerlink" title="5 Set ↔ 数组"></a>5 Set ↔ 数组</h4><table>
<thead>
<tr>
<th>方式</th>
<th>转换</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[...set]</code></td>
<td>Set → 数组</td>
<td>展开语法，可以展开可迭代对象</td>
</tr>
<tr>
<td><code>Array.from(set)</code></td>
<td>Set → 数组</td>
<td>数组静态方法，将可迭代对象转为数组</td>
</tr>
<tr>
<td><code>new Set(arr)</code></td>
<td>数组 → Set</td>
<td>Set 构造方法，将数组转为 Set</td>
</tr>
</tbody></table>
<h3 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2 WeakSet"></a>2 WeakSet</h3><ol>
<li>用法同 Set 大致相同</li>
<li>与 Set 的区别<ol>
<li>WeakSet 只能存引用数据类型</li>
<li>WeakSet 对元素的引用是弱引用<ul>
<li>如果没有其他引用对元素进行引用，那么 GC 可以对该元素进行回收</li>
</ul>
</li>
<li>WeakSet 不可遍历<ul>
<li>因为 WeakSet 是弱引用，其中的对象随时有可能别垃圾回收掉</li>
<li>如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁</li>
<li>所以存储到 WeakSet 中的对象是没办法获取的</li>
</ul>
</li>
<li>没有<code>size</code> 属性</li>
<li>原型方法只有 <code>add() delete() has()</code></li>
</ol>
</li>
</ol>
<h3 id="3-Map"><a href="#3-Map" class="headerlink" title="3 Map"></a>3 Map</h3><h4 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li>Map 是键值对的集合，且键有序（存取一致）</li>
<li>对象的键只能是字符串（后来加了 Symbol），Map 的键可以是任何类型</li>
<li>如果键相等，后边的值回覆盖前边</li>
<li>判断键相等 基于 <code>sameValueZero</code> 算法<ul>
<li>类似 <code>===</code>，除了NaN，<code>NaN === NaN </code>返回 <code>false</code>，但是在 Map 中看作相等</li>
</ul>
</li>
</ol>
<h4 id="2-构造函数-1"><a href="#2-构造函数-1" class="headerlink" title="2 构造函数"></a>2 构造函数</h4><ul>
<li><code>new Map([iterable])</code><ul>
<li><code>iterable</code><ul>
<li>可迭代对象，其元素为键值对。</li>
<li>如数组为 <code>[[&#39;name&#39;,&#39;xiaoming&#39;],[&#39;age&#39;,18]]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-原型属性-Map-prototype"><a href="#3-原型属性-Map-prototype" class="headerlink" title="3 原型属性 Map.prototype."></a>3 原型属性 <code>Map.prototype.</code></h4><table>
<thead>
<tr>
<th>原型属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>size</code></td>
<td>Map 集合中键值对的个数</td>
</tr>
</tbody></table>
<h4 id="4-原型方法-Map-prototype"><a href="#4-原型方法-Map-prototype" class="headerlink" title="4 原型方法 Map.prototype."></a>4 原型方法 <code>Map.prototype.</code></h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>set(key, value)</code></td>
<td>向 Map 添加键值对，返回 Map</td>
</tr>
<tr>
<td><code>get(key)</code></td>
<td>根据 <code>key</code> 获取 <code>value</code>，没有返回 <code>undefined</code></td>
</tr>
<tr>
<td><code>delete(key)</code></td>
<td>根据 <code>key</code> 删除键值对，删除成功返回 <code>true</code>，否则返回 <code>false</code></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空 Map</td>
</tr>
<tr>
<td><code>has(key)</code></td>
<td>判断指定 <code>key</code> 的元素是否存在</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>返回键的迭代器对象</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>返回值的迭代器对象</td>
</tr>
<tr>
<td><code>entries()</code></td>
<td>返回键值对的迭代器对象，键值对形式为<code>[key, value]</code></td>
</tr>
<tr>
<td><code>forEach(callback[, thisArg])</code></td>
<td>遍历 Map，按键插入顺序依次执行回调函数</td>
</tr>
</tbody></table>
<h4 id="5-Map-↔-数组"><a href="#5-Map-↔-数组" class="headerlink" title="5 Map ↔ 数组"></a>5 Map ↔ 数组</h4><table>
<thead>
<tr>
<th>方式</th>
<th>转换</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[...map]</code></td>
<td>Map → 数组</td>
<td>展开语法，可以展开可迭代对象</td>
</tr>
<tr>
<td><code>Array.from(map)</code></td>
<td>Map → 数组</td>
<td>数组静态方法，将可迭代对象转为数组</td>
</tr>
<tr>
<td><code>new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]])</code></td>
<td>数组 → Map</td>
<td>将一个二维键值对数组转换成一个 Map 对象</td>
</tr>
</tbody></table>
<h3 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4 WeakMap"></a>4 WeakMap</h3><ol>
<li>用法同Map大致相同</li>
<li>与Map的区别<ol>
<li>WeakMap 的键只能是引用数据类型（不能为 <code>null</code> ）</li>
<li>WeakMap 的键是弱引用</li>
<li>WeakMap 不能遍历</li>
<li>WeakMap 没有<code>size</code>属性</li>
<li>WeakMap 原型方法只有 <code>set() get() delete() has()</code></li>
</ol>
</li>
</ol>
<h2 id="6-6-WeakRefs"><a href="#6-6-WeakRefs" class="headerlink" title="6.6 WeakRefs"></a>6.6 WeakRefs</h2><ol>
<li><p>默认将一个对象赋值给另外一个引用，那么这个引用是一个强引用</p>
</li>
<li><p>如果我们希望是一个弱引用的话，可以使用 WeakRef</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let info = new WeakRef(obj);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-7-FinalizationRegistry"><a href="#6-7-FinalizationRegistry" class="headerlink" title="6.7 FinalizationRegistry"></a>6.7 FinalizationRegistry</h2><ol>
<li><p>FinalizationRegistry 对象可以让你在对象被垃圾回收时请求一个回调</p>
</li>
<li><p>FinalizationRegistry 提供了这样的一种方法：当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。（清理回调有时被称为 finalizer ）;</p>
</li>
<li><p>通过调用register方法，注册任何你想要清理回调的对象，传入该对象和所含的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 创建 FinalizationRegistry 对象并传入回调函数</span><br><span class="line">const fr = new FinalizationRegistry(callback)</span><br><span class="line"></span><br><span class="line">2. 注册对象</span><br><span class="line">fr.register(obj, &quot;haha&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="七-响应式"><a href="#七-响应式" class="headerlink" title="七 响应式"></a>七 响应式</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><ol>
<li>当数据（更多是对象）发生变化时，自动执行一些代码，就称为响应式</li>
<li>监听对象的操作<ol>
<li>通过属性描述符中的存储属性描述符来监听，但有弊端<ol>
<li>Object.defineProperty 设计的初衷，不是为了去监听截止一个对象中所有的属性的</li>
<li>想监听更加丰富的操作，比如新增属性、删除属性，那么 Object.defineProperty 是无能为力的</li>
</ol>
</li>
<li>ES6 新增的 Proxy 类，如果希望监听一个对象的相关操作，可以先创建一个代理对象（Proxy对象）</li>
</ol>
</li>
</ol>
<h2 id="7-2-Proxy"><a href="#7-2-Proxy" class="headerlink" title="7.2 Proxy"></a>7.2 Proxy</h2><h3 id="1-构造函数-2"><a href="#1-构造函数-2" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ul>
<li><code>new Proxy(target, handler)</code><ul>
<li>返回一个代理对象</li>
<li><code>target</code><ul>
<li>用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li>
</ul>
</li>
<li><code>handler</code><ul>
<li>处理器对象，有 13 个拦截相应操作的函数，如果没有配置，则执行默认操作</li>
<li>注意：处理操作都是针对代理对象的，目标对象无效。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-handler（处理器对象）"><a href="#2-handler（处理器对象）" class="headerlink" title="2 handler（处理器对象）"></a>2 handler（处理器对象）</h3><ol>
<li><p><code>get(target, property, receiver)</code></p>
<ul>
<li><p>get 方法拦截属性的获取，可以返回任何值</p>
</li>
<li><p>参数</p>
<ul>
<li><p><code>target</code></p>
<ul>
<li>目标对象（侦听的对象）</li>
</ul>
</li>
<li><p><code>property</code></p>
<ul>
<li>被获取的属性名</li>
</ul>
</li>
<li><p><code>reveiver</code></p>
<ul>
<li>调用的代理对象</li>
<li>如果源对象有setter、getter的访问器属性，那么可以通过 receiver 来改变里面的 this</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>set(target, property, value, receiver)</code></p>
<ul>
<li><p>set 方法拦截属性的设置，严格模式下必须返回布尔值，且如果返回 false 会报错</p>
</li>
<li><p>参数</p>
<ul>
<li><code>value</code><ul>
<li>被设置的新值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>apply(target, thisArg, argumentsList)</code></p>
<ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>被调用时的上下文对象</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>被调用时的参数数组</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>apply 方法拦截函数调用，可以返回任何值<ol>
<li>直接调用</li>
<li><code>Function.prototype.call()</code> 方式调用</li>
<li><code>Function.prototype.apply()</code> 方式调用</li>
<li><code>Reflet.apply()</code> 方式调用</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>has(target, prop)</code></p>
<ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标对象</li>
</ul>
</li>
<li><code>prop</code><ul>
<li>需要检查是否存在的属性.</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截 <code>prop in object</code> 语句，返回布尔值</li>
</ul>
</li>
</ul>
</li>
<li><p><code>construct(target, argumentsList, newTarget)</code></p>
<ul>
<li>参数<ul>
<li><code>target</code><ul>
<li>目标构造函数</li>
</ul>
</li>
<li><code>argumentsList</code><ul>
<li>constructor的参数列表</li>
</ul>
</li>
<li><code>newTarget</code><ul>
<li>生成的代理对象（即代理构造函数）</li>
</ul>
</li>
</ul>
</li>
<li>说明<ul>
<li>拦截new操作，必须返回一个对象</li>
</ul>
</li>
</ul>
</li>
<li><p><code>deleteProperty(target, prop)</code></p>
<ul>
<li>拦截<code>delete</code> 操作，必须返回布尔值</li>
</ul>
</li>
<li><p><code>defineProperty(target, property, descriptor)</code></p>
<ul>
<li>拦截<code>Object.defineProperty()</code>，必须返回布尔值</li>
</ul>
</li>
<li><p><code>getOwnPropertyDescriptor(target, prop)</code></p>
<ul>
<li>拦截 <code>Object.getOwnPropertyDescriptor()</code>，必须返回一个对象或undefined</li>
</ul>
</li>
<li><p><code>getPrototypeOf(target)</code></p>
<ul>
<li>拦截获取原型操作，即方法 <code>Object.getPrototypeOf</code></li>
</ul>
</li>
<li><p><code>setPrototypeOf(target, prototype)</code></p>
</li>
</ol>
<ul>
<li>拦截设置原型操作，返回布尔值，即方法 <code>Object.setPrototypeOf</code></li>
</ul>
<ol start="11">
<li><p><code>preventExtensions(target)</code></p>
<ul>
<li>拦截 <code>Object.preventExtensions()</code>，返回一个布尔值</li>
</ul>
</li>
<li><p><code>isExtensible(target)</code></p>
<ul>
<li>拦截<code>Object.isExtensible()</code>，必须返回布尔值</li>
</ul>
</li>
<li><p><code>ownKeys(target)</code></p>
<ul>
<li>拦截 <code>Object.getOwnPropertyNames</code> 和 <code>Object.getOwnPropertySymbols</code></li>
</ul>
</li>
</ol>
<h2 id="7-3-Reflect"><a href="#7-3-Reflect" class="headerlink" title="7.3 Reflect"></a>7.3 Reflect</h2><ol>
<li><p><code>Reflect</code> 是一个对象而并非构造函数，不能 <code>new</code>，<code>Reflect</code> 的所有属性和方法都是静态的</p>
</li>
<li><p>为何会有 Reflect</p>
<ol>
<li>早期的ECMA规范中没有考虑到这种对 对象本身 的操作如何设计会更加规范，所以将这些API放到了Object上面，但是Object作为一个构造函数，这些操作实际上放到它身上并不合适</li>
<li>一些类似于 in、delete操作符，让JS看起来是会有一些奇怪的</li>
</ol>
</li>
<li><p>Reflect 的作用</p>
<ol>
<li>将 <code>Object</code> 对象的一些明显属于语言内部的方法（如<code>Object.defineProperty()</code>），放到 <code>Reflect</code> 对象上</li>
<li>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理，如 <code>Object.defineProperty()</code>无法定义属性时，会抛出错误，而<code>Reflect.defineProperty()</code>会返回false</li>
<li>让 <code>Object</code> 操作都变成函数行为<ul>
<li> <code>prop in object</code> ，对应`Reflect.has(obj, prop)``</li>
<li> ``delete obj.prop<code>，对应</code>Reflect.deleteProperty(obj, prop)`</li>
</ul>
</li>
</ol>
</li>
<li><p>API</p>
<ol>
<li><p>Reflect 对象的方法和 handler 是一一对应的，也是 13 个</p>
</li>
<li><p>在使用代理拦截某些操作时，使用 Reflect 的方法可以保证原生行为能正常执行</p>
</li>
<li><p>reflect 的 constructor 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Dog(args)&#123;</span><br><span class="line">	code...</span><br><span class="line">&#125;</span><br><span class="line">function Cat()&#123;&#125;</span><br><span class="line">// 执行构造函数 Dog 中的内容，但是创建出的是 Cat 类型</span><br><span class="line">Reflect.constructor(Dog, args, Cat);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/03-JS%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/03-JS%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">03-JS数组和函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-14 19:56:43 / 修改时间：19:59:21" itemprop="dateCreated datePublished" datetime="2022-02-14T19:56:43+08:00">2022-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-数组"><a href="#一-数组" class="headerlink" title="一 数组"></a>一 数组</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><ol>
<li>数组都是 <code>Array</code> 的实例</li>
<li>数组可以存任意类型的数据</li>
<li>数组长度可变</li>
<li>ES6 明确数组中空位值为 <code>undefined</code></li>
</ol>
<h2 id="1-2-数组的创建和清空"><a href="#1-2-数组的创建和清空" class="headerlink" title="1.2 数组的创建和清空"></a>1.2 数组的创建和清空</h2><h3 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1 创建数组"></a>1 创建数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 数组字面量</span></span><br><span class="line"><span class="keyword">let</span> arr = [ele0, ele1, ..., eleN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 Array 构造函数</span></span><br></pre></td></tr></table></figure>

<h3 id="2-清空数组"><a href="#2-清空数组" class="headerlink" title="2 清空数组"></a>2 清空数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 将原数组指向一个空数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 将数组长度置为 0</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 使用 splice() 方法</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">0</span>, arr.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 循环一个个删</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	arr.pop();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Array"><a href="#1-3-Array" class="headerlink" title="1.3 Array"></a>1.3 Array</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Array(arrayLength)</code></td>
<td>创建一个指定长度的数组，<code>arrayLength</code> ：0-2<sup>32</sup>-1 之间的整数</td>
</tr>
<tr>
<td><code>new Array(ele0, ele1[, ...[, eleN]])</code></td>
<td>创建一个包含指定元素的数组</td>
</tr>
<tr>
<td><code>Array(...)</code></td>
<td>和 <code>new Array(...)</code> 是等同的</td>
</tr>
</tbody></table>
<h3 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2 实例属性"></a>2 实例属性</h3><table>
<thead>
<tr>
<th>实例属性</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>读写</td>
<td>数组元素个数</td>
</tr>
</tbody></table>
<h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3  静态方法"></a>3  静态方法</h3><ol>
<li><code>Array.isArray(obj)</code><ul>
<li>如果值是 Array，则返回true，否则返回false（用来弥补<code>typeof</code>，因为<code>typeof 数组</code> 返回的是<code>object</code>）</li>
</ul>
</li>
<li><code>Array.of(element0[, element1[, ...[, elementN]]])</code><ul>
<li>将一组值转换为数组（用来弥补构造函数，构造函数参数个数不同会导致结果不同。）</li>
</ul>
</li>
<li><code>Array.from(arrayLike[, mapFn[, thisArg]])</code><ul>
<li>从一个类数组对象或可迭代对象创建一个新的浅拷贝的数组实例并返回</li>
<li><code>mapFn</code><ul>
<li>如果指定了该参数，新数组中的每个元素都会执行该回调函数</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调函数 mapFn 时的 this 对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-原型方法"><a href="#4-原型方法" class="headerlink" title="4 原型方法"></a>4 原型方法</h3><h4 id="1-获取"><a href="#1-获取" class="headerlink" title="1 获取"></a>1 获取</h4><ol>
<li><code>valueOf()</code><ul>
<li>返回数组本身</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回数组的字符串形式</li>
</ul>
</li>
<li><code>join([separator])</code><ul>
<li>以指定分隔符（默认为逗号）将所有数组成员连接为一个字符串返回</li>
</ul>
</li>
</ol>
<h4 id="2-增删改"><a href="#2-增删改" class="headerlink" title="2 增删改"></a>2 增删改</h4><ol>
<li><code>push(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的末尾，并返回该数组的新长度，改变原数组</li>
<li>如果参数为数组，把数组作为元素添加到数组中。(二维数组)</li>
</ul>
</li>
<li><code>pop()</code><ul>
<li>删除并返回最后一个元素，改变原数组</li>
</ul>
</li>
<li><code>unshift(element1, ..., elementN)</code><ul>
<li>将一个或多个元素添加到数组的开头，并返回该数组的新长度，改变原数组</li>
<li>参数可以是数组（二维数组）</li>
</ul>
</li>
<li><code>shift()</code><ul>
<li>删除并返回第一个元素，改变原数组</li>
</ul>
</li>
<li><code>fill(value[, start[, end]])</code><ul>
<li>使用指定值填充数组，可指定开始结束索引，返回修改后的数组</li>
</ul>
</li>
<li><code>splice(start[, deleteCount[, item1[, item2[, ...]]]])</code><ul>
<li>删除目标数组的一部分成员，并可以在删除的位置添加新的数组成员，返回被删除的元素组成的数组，改变原数组</li>
</ul>
</li>
<li><code>slice([begin[, end]])</code><ul>
<li>提取目标数组的一部分，返回一个浅拷贝新数组，原数组不变</li>
</ul>
</li>
<li><code>concat(value1, value2, ..., valueN)</code><ul>
<li>将一个或多个值合并到数组中，返回新数组，不改变原数组</li>
</ul>
</li>
<li><code>copyWithin(target[, start[, end]])</code><ul>
<li>复制数组的一部分到数组指定位置（覆盖原有成员），并返回数组，改变原数组但不改变数组长度（因为会覆盖原有成员）</li>
<li><code>target</code><ul>
<li>目标位置</li>
</ul>
</li>
<li><code>start</code><ul>
<li>复制的起始索引，默认为0</li>
</ul>
</li>
<li><code>end</code><ul>
<li>复制的终止索引（不含），默认为尾部</li>
</ul>
</li>
</ul>
</li>
<li><code>flat([depth])</code><ul>
<li>将数组降维，按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回</li>
<li><code>depth</code><ul>
<li>指定结构深度，默认值为 1，即只可以将二维数组合并成一维数组</li>
</ul>
</li>
</ul>
</li>
<li><code>flatMap(callback[, thisArg])</code><ul>
<li>flatMap 是先进行 map 操作，再做 flat 的操作（深度为1）</li>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="3-查"><a href="#3-查" class="headerlink" title="3 查"></a>3 查</h4><ol>
<li><code>indexOf(searchElement[, fromIndex])</code><ul>
<li>返回第一个匹配索引，如果不存在，则返回 <code>-1</code></li>
</ul>
</li>
<li><code>lastIndexOf(searchElement[, fromIndex])</code><ul>
<li>返回从后往前的第一个匹配索引，如果不存在，则返回 <code>-1</code></li>
</ul>
</li>
<li><code>includes(valueToFind[, fromIndex])</code><ul>
<li>判断数组是否包含指定元素</li>
</ul>
</li>
<li><code>find(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的值，否则返回 undefined</li>
<li><code>callback(element[, index[, array]])</code><ul>
<li><code>element</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
<li><code>thisArg</code><ul>
<li>执行回调时函数时this 指向的对象。</li>
</ul>
</li>
</ul>
</li>
<li><code>findIndex(callback[, thisArg])</code><ul>
<li>返回数组中第一个满足所提供测试函数（返回true）的元素的索引，否则返回 -1</li>
</ul>
</li>
</ol>
<h4 id="4-排序"><a href="#4-排序" class="headerlink" title="4 排序"></a>4 排序</h4><ol>
<li><code>reverse()</code><ul>
<li>反转数组并返回，改变原数组</li>
</ul>
</li>
<li><code>sort([compareFunction])</code><ul>
<li>默认是按照字典顺序排序，返回排序后的数组，改变原数组</li>
<li><code>compareFunction(value1, value2)</code><ul>
<li>返回一个数字，如果小于0则value1排在value2之前</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-循环遍历"><a href="#5-循环遍历" class="headerlink" title="5 循环遍历"></a>5 循环遍历</h4><ol>
<li><code>forEach(callback[, thisArg])</code><ul>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>keys()</code><ul>
<li>返回数组元素键的迭代器对象</li>
</ul>
</li>
<li><code>values()</code><ul>
<li>返回数组元素值的迭代器对象</li>
</ul>
</li>
<li><code>entries()</code><ul>
<li>返回数组元素键值对的迭代器对象</li>
</ul>
</li>
</ol>
<h4 id="6-扩展方法"><a href="#6-扩展方法" class="headerlink" title="6 扩展方法"></a>6 扩展方法</h4><ol>
<li><code>every(callback[, thisArg])</code><ul>
<li>判断数组元素是否全部能通过指定测试函数，返回布尔值，一个元素返回 <code>false</code>，则 <code>every()</code>立即返回 <code>false</code></li>
<li><code>callback(currentValue[, index[, array]])</code><ul>
<li><code>currentValue</code>：当前遍历的元素</li>
<li><code>index</code>：当前遍历到的索引</li>
<li><code>array</code>：当前数组</li>
</ul>
</li>
</ul>
</li>
<li><code>some(callback[, thisArg])</code><ul>
<li>数组中有至少一个元素通过回调函数的测试就会返回 <code>true</code>；</li>
</ul>
</li>
<li><code>filter(callback[, thisArg])</code><ul>
<li>返回一个新的由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组</li>
</ul>
</li>
<li><code>map(callback[, thisArg])</code><ul>
<li> 对数组中每一个元素执行回调函数，返回每一个回调函数结果组成的新数组</li>
</ul>
</li>
<li><code>reduce(callback[, initialValue])</code><ul>
<li>返回回调函数累计处理的结果</li>
<li><code>callback(accumulator, currentValue[, index[, array]])</code><ul>
<li><code>accumulator</code><ul>
<li>第一次循环<ol>
<li>有<code>initialValue</code>，则为<code>initialValue</code></li>
<li>无<code>initialValue</code>，则为数组第一个元素</li>
</ol>
</li>
<li>从第二次循环往后为回调函数返回值</li>
</ul>
</li>
<li><code>currentValue</code><ul>
<li>数组中当前循环的元素</li>
<li>第一次循环时，如果没有<code>initialValue</code>，由于<code>accumulator</code>是数组第一个元素，则<code>currentValue</code>会从第二个元素开始循环</li>
</ul>
</li>
<li><code>index</code><ul>
<li>数组中当前循环的元素的索引</li>
</ul>
</li>
<li><code>array</code><ul>
<li>当前数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>reduceRight(callback[, initialValue])</code><ul>
<li>与<code>reduce()</code>相似，只是从右向左遍历数组</li>
</ul>
</li>
</ol>
<h1 id="二-函数"><a href="#二-函数" class="headerlink" title="二 函数"></a>二 函数</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ol>
<li>每个 JavaScript 函数都是一个 <code>Function</code> 实例</li>
<li>函数作为对象中的属性通常称为方法</li>
</ol>
<h2 id="2-2-定义函数"><a href="#2-2-定义函数" class="headerlink" title="2.2 定义函数"></a>2.2 定义函数</h2><h3 id="1-方式"><a href="#1-方式" class="headerlink" title="1 方式"></a>1 方式</h3><ol>
<li><p>函数声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名(参数列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>函数提升（提升优先级高于 <code>var</code> 变量提升），所以可以在定义函数之前的位置调用函数</li>
<li>全局声明的函数会添加到 <code>window</code> 对象中</li>
<li>优先级高于函数表达式</li>
</ol>
</li>
<li><p>函数表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var/let/const 函数名 = function (参数列表) &#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// var 虽然有变量提升，但赋值操作不会提升，所以函数表达式必须先声明后调用</span><br></pre></td></tr></table></figure></li>
<li><p>Function 构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var/let/const 函数名 = new Function(&quot;参数列表&quot;,&quot;函数体&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-参数"><a href="#2-参数" class="headerlink" title="2 参数"></a>2 参数</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h4><ol>
<li><p>形参 <code>parameter</code> ；实参 <code>argument</code></p>
<ul>
<li>形参是默认声明的，不需用 <code>var/let/const</code> 修饰</li>
<li>实参数量小于形参时，没有传递的形参值为 <code>undefined</code></li>
<li>实参数量大于形参时，多余的实参将忽略并不会报错</li>
</ul>
</li>
<li><p>参数默认值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b = 2) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在形参上可以直接定义参数默认值，当对应实参没有值或值为 undefined 时，使用默认值</li>
<li>带默认值的参数通常写最后，如果写前面，传参时需要用 undefined 占位</li>
<li>带默认值会改变函数的 length 的个数，默认值及其后面的参数都不计算在 length 之内</li>
<li>当参数有默认值时，会形成一个参数作用域</li>
</ol>
</li>
</ol>
<h4 id="2-arguments"><a href="#2-arguments" class="headerlink" title="2 arguments"></a>2 arguments</h4><ol>
<li>所有函数（箭头函数除外）内部都有 arguments，箭头函数中使用 arguments 会去上层作用域查找</li>
<li>arguments 是一个类数组(array-like)对象（长得像一个数组，本质是一个对象），存储了传递的所有实参<ol>
<li>有数组的一些特性，如 length 和 index，但没有数组的方法</li>
<li><code>arguments.callee</code>：获取当前 arguments 所在的函数</li>
</ol>
</li>
</ol>
<h4 id="3-剩余参数"><a href="#3-剩余参数" class="headerlink" title="3 剩余参数"></a>3 剩余参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(a, b, ...theArgs) &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>剩余参数是一个数组，用于接收形参外的所有参数（类似于 java 可变参数）</li>
<li>剩余参数必须是最后一个参数</li>
<li>剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参</li>
<li>arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，即剩余参数可以使用所有的数组方法</li>
</ol>
<h2 id="2-3-立即执行函数-IIFE"><a href="#2-3-立即执行函数-IIFE" class="headerlink" title="2.3 立即执行函数 IIFE"></a>2.3 立即执行函数 IIFE</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式 一</span></span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">形参列表</span>)</span>&#123;&#125;(实参列表)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 形式 二</span></span><br><span class="line">(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">形参列表</span>)</span>&#123;&#125;</span><br><span class="line">)(实参列表)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Imdiately Invoked Function Expression</code></li>
<li>形成单独的作用域，封装遍历，避免重名…</li>
</ol>
<h2 id="2-4-箭头函数（lambda）"><a href="#2-4-箭头函数（lambda）" class="headerlink" title="2.4 箭头函数（lambda）"></a>2.4 箭头函数（lambda）</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>箭头函数内部不绑定 this，是根据外层作用域来决定，指向定义时所在作用域的 this</li>
<li>箭头函数没有 <code>prototype</code> 属性，不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令</li>
<li>箭头函数内部不存在 <code>arguments</code> 对象</li>
<li>箭头函数不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 <code>Generator</code> 函数</li>
</ol>
<h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2 语法"></a>2 语法</h3><ol>
<li><p>基础语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>没有参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当且仅当只有一个参数时，小括号可以省略</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数体只有一句且是返回语句时，<code>return</code>、分号和大括号都可以省略</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt;&#123; <span class="keyword">return</span> expression; &#125;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">//  注意：如果返回的是一个对象，要用()包括，因为&#123;&#125;会被认为是一个代码块</span></span><br><span class="line">(param1, param2, …, paramN) =&gt; (&#123;<span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-5-Function"><a href="#2-5-Function" class="headerlink" title="2.5 Function"></a>2.5 Function</h2><h3 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><ul>
<li><code>new Function (variableStr, functionBodyStr)</code><ul>
<li><code>variableStr</code><ul>
<li>形参字符串，字符串中多个参数用逗号分隔</li>
</ul>
</li>
<li><code>functionBodyStr</code><ul>
<li>函数体的字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-实例属性-1"><a href="#2-实例属性-1" class="headerlink" title="2 实例属性"></a>2 实例属性</h3><table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>函数的形参个数</td>
</tr>
<tr>
<td><code>name</code></td>
<td>函数的名称</td>
</tr>
</tbody></table>
<h3 id="3-原型方法-Function-prototype"><a href="#3-原型方法-Function-prototype" class="headerlink" title="3 原型方法 Function.prototype."></a>3 原型方法 <code>Function.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>call(thisArg, arg1, arg2, ...)</code></td>
<td>使用指定的 <code>this</code> 值和实参列表来调用函数</td>
<td>执行函数</td>
</tr>
<tr>
<td><code>apply(thisArg, [argsArray])</code></td>
<td>同<code>call()</code>，不同的是接受的是一个实参数组</td>
<td>执行函数</td>
</tr>
<tr>
<td><code>bind(thisArg[, arg1[, arg2[, ...]]])</code></td>
<td>使用指定的 <code>this</code> 和实参列表创建一个原函数的拷贝并返回，<code>bind</code> 实参优先级高于调用实参</td>
<td>创建函数</td>
</tr>
</tbody></table>
<h2 id="2-6-全局函数"><a href="#2-6-全局函数" class="headerlink" title="2.6 全局函数"></a>2.6 全局函数</h2><table>
<thead>
<tr>
<th>全局函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>encodeURI(URI)</code></td>
<td>使用 UTF-8 编码，编码后的格式为UTF-8编码的每个字节前加 <code>%</code>，如 <code>安</code> 编码后 <code>%E5%AE%89</code></td>
</tr>
<tr>
<td><code>decodeURI(encodedURI)</code></td>
<td><code>encodeURI(URI)</code> 对应的解码函数</td>
</tr>
<tr>
<td><code>encodeURIComponent(str)</code></td>
<td>类似<code>encodeURI()</code>，区别在于不会编码的字符</td>
</tr>
<tr>
<td><code>decodeURIComponent(encodedURI)</code></td>
<td><code>encodeURIComponent()</code>对应的解码函数</td>
</tr>
<tr>
<td><code>isFinite(value)</code></td>
<td>同 <code>Number.isFinite(value)</code></td>
</tr>
<tr>
<td><code>isNaN(value)</code></td>
<td>同 <code>Number.isNaN(value)</code></td>
</tr>
<tr>
<td><code>parseInt(string[, radix])</code></td>
<td>同 <code>Number.parseInt(string[, radix])</code></td>
</tr>
<tr>
<td><code>parseFloat(string)</code></td>
<td>同 <code>Number.parseFloat(string)</code></td>
</tr>
<tr>
<td><code>eval(string)</code>（不要使用）</td>
<td>将传入的字符串当做 JavaScript 代码进行执行</td>
</tr>
</tbody></table>
<ul>
<li><code>encodeURI(URI)</code> 和 <code>encodeURIComponent(str)</code> 区别<ol>
<li><code>encodeURI(URI)</code> 不会编码的字符    <ol>
<li><code>; , / ? : @ &amp; = + $</code>        </li>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
<li><code>#</code></li>
</ol>
</li>
<li><code>encodeURIComponent(str)</code> 不会编码的字符<ol>
<li><code>字母 数字 - _ . ! ~ * &#39; ( )</code></li>
</ol>
</li>
<li>使用场景<ol>
<li>对整个 URI 编码，使用 <code>encodeURI(URI)</code></li>
<li>对 URI 中的参数编码，使用 <code>encodeURIComponent(str)</code></li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="三-函数式编程"><a href="#三-函数式编程" class="headerlink" title="三 函数式编程"></a>三 函数式编程</h1><h2 id="3-1-纯函数"><a href="#3-1-纯函数" class="headerlink" title="3.1 纯函数"></a>3.1 纯函数</h2><ol>
<li>纯函数在相同的输入值时，需产生相同的输出</li>
<li>纯函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关</li>
<li>纯函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等<ul>
<li>副作用表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响，比如修改了全局变量，修改参数或者改变外部的存储</li>
<li>如数组的 slice 就是一个纯函数，不会修改传入的参数，截取数组时不会对原数组进行任何操作,而是生成一个新的数组；而 splice 截取数组, 会返回一个新的数组, 也会对原数组进行修改，所以 splice 不是纯函数</li>
</ul>
</li>
</ol>
<h2 id="3-2-柯里化（currying）"><a href="#3-2-柯里化（currying）" class="headerlink" title="3.2 柯里化（currying）"></a>3.2 柯里化（currying）</h2><ol>
<li><p>柯里化是把接收多个参数的函数，变成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数，而且返回结果的新函数的技术</p>
</li>
<li><p>柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”</p>
</li>
<li><p>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数，这个过程就称之为柯里化</p>
</li>
<li><p>柯里化的好处</p>
<ol>
<li>单一职责</li>
<li>对一些逻辑的复用</li>
</ol>
</li>
<li><p>自动柯里化函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn) &#123;</span><br><span class="line">	function curried(...args) &#123;</span><br><span class="line">		// 如果参数已足够，执行函数并返回结果</span><br><span class="line">		if(args.length &gt;= fn.length) &#123;</span><br><span class="line">			return fn.call(this, ...args);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return function(...restArgs) &#123;</span><br><span class="line">				return curried.call(this, ...args, ...restArgs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return curried;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-3-组合函数"><a href="#3-3-组合函数" class="headerlink" title="3.3 组合函数"></a>3.3 组合函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function compose(...fns) &#123;</span><br><span class="line">	// 遍历所有原生，如果不是函数直接报错</span><br><span class="line">	let len = fns.length;</span><br><span class="line">	for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">		let fn = fns[i];</span><br><span class="line">		if(typeof fn !== &#x27;function&#x27;) &#123;</span><br><span class="line">			throw new TypeError(&#x27;需要一个函数&#x27;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 取出所有函数一次调用</span><br><span class="line">	return function(...arg) &#123;</span><br><span class="line">		// 先获取第一次执行结果</span><br><span class="line">		let index = 0;</span><br><span class="line">		let result = len ? fns[index].apply(this, args) : args;</span><br><span class="line">		while(++index &lt; len) &#123;</span><br><span class="line">			result = fns[index].call(this, result);</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>组合（Compose）函数是在JavaScript开发过程中一种对函数的使用技巧、模式</li>
<li>比如我们现在需要对某一个数据进行函数的调用，执行两个函数fn1和fn2，这两个函数是依次执行的，如果每次我们都需要进行两个函数的调用，操作上就会显得重复，将这两个函数组合起来，自动依次调用的过程就是对函数的组合，我们称之为 组合函数（Compose Function）</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/02-JS%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/02-JS%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">02-JS基本数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-14 19:56:30 / 修改时间：19:58:54" itemprop="dateCreated datePublished" datetime="2022-02-14T19:56:30+08:00">2022-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-number"><a href="#一-number" class="headerlink" title="一 number"></a>一 number</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>任意数字</code></td>
<td>整数或者浮点数</td>
</tr>
<tr>
<td><code>+Infinity</code></td>
<td>正无穷</td>
</tr>
<tr>
<td><code>-Infinity</code></td>
<td>负无穷</td>
</tr>
<tr>
<td><code>NaN</code></td>
<td><code>not a number</code> 一个不是数字的数字类型</td>
</tr>
</tbody></table>
<ol>
<li>JavaScript 的 number 类型为双精度IEEE 754 64位浮点类型。范围（-2<sup>53</sup>- 2<sup>53</sup>） </li>
<li>JavaScript 内部，整数和浮点数采用的是同样的储存方法。所以<code>1===1.0</code> 为true</li>
<li>进制<ul>
<li>十进制：默认</li>
<li>二进制：以 <code>0b</code> 开头</li>
<li>八进制：以 <code>0o </code>开头</li>
<li>十六进制：以 <code>0x</code> 开头</li>
</ul>
</li>
<li>数字过长时，用 _ 作为连接符：100_000_000</li>
</ol>
<h2 id="2-2-包装类（Number）"><a href="#2-2-包装类（Number）" class="headerlink" title="2.2 包装类（Number）"></a>2.2 包装类（Number）</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Number([value])</code></td>
<td>构造函数</td>
<td>创建一个 <code>Number</code> 对象</td>
</tr>
<tr>
<td><code>Number([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个 <code>number</code></td>
</tr>
</tbody></table>
<h3 id="2-静态属性"><a href="#2-静态属性" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number.POSITIVE_INFINITY</code></td>
<td>正无穷，指向 <code>+Infinity</code></td>
</tr>
<tr>
<td><code>Number.NEGATIVE_INFINITY</code></td>
<td>负无穷，指向 <code>-Infinity</code></td>
</tr>
<tr>
<td><code>Number.NaN</code></td>
<td><code>NaN</code></td>
</tr>
<tr>
<td><code>Number.MIN_VALUE</code></td>
<td>最小正值</td>
</tr>
<tr>
<td><code>Number.MAX_VALUE</code></td>
<td>最大数值</td>
</tr>
<tr>
<td><code>Number.MIN_SAFE_INTEGER</code></td>
<td>JS 中能够准确表示的整数范围下限</td>
</tr>
<tr>
<td><code>Number.MAX_SAFE_INTEGER</code></td>
<td>JS 中能够准确表示的整数范围上限</td>
</tr>
<tr>
<td><code>Number.EPSILON</code></td>
<td>表示 1 与大于 1 的最小的浮点数之间的差值，即 JS 的精度</td>
</tr>
</tbody></table>
<h3 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number.isNaN(value)</code></td>
<td>判断是否是 <code>NaN</code></td>
</tr>
<tr>
<td><code>Number.isFinite(value)</code></td>
<td>判断否是有穷数</td>
</tr>
<tr>
<td><code>Number.isInteger(value)</code></td>
<td>判断是否是整数</td>
</tr>
<tr>
<td><code>Number.parseInt(string[, radix])</code></td>
<td>将一个字符串转换成指定进制的整数，<code>radix</code> ：进制 <code>2-36</code>，默认 <code>10</code></td>
</tr>
<tr>
<td><code>Number.parseFloat(string)</code></td>
<td>将一个字符串转换成浮点数</td>
</tr>
</tbody></table>
<ol>
<li><code>Number.isNaN(value)</code> &amp; <code>window.isNaN()</code><ul>
<li>全局函数 <code>isNaN()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isNaN()</code> 只对数值有效，非数值直接返回 <code>false</code></li>
</ul>
</li>
<li><code>Number.isFinite(value)</code> &amp; <code>window.isFinite()</code><ul>
<li>全局函数 <code>isFinite()</code> 会先将非数值转换为数值，再进行判断</li>
<li><code>Number.isFinite()</code> 只对数值有效，非数值直接返回 <code>false</code></li>
</ul>
</li>
</ol>
<h3 id="4-原型方法-Number-prototype"><a href="#4-原型方法-Number-prototype" class="headerlink" title="4 原型方法 Number.prototype."></a>4 原型方法 <code>Number.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>valueOf()</code></td>
<td>返回 <code>number</code> 值</td>
</tr>
<tr>
<td><code>toString([radix])</code></td>
<td>返回字符串形式</td>
</tr>
<tr>
<td><code>toFixed([digits])</code></td>
<td>返回保留指定位数浮点数的字符串</td>
</tr>
</tbody></table>
<h1 id="二-boolean"><a href="#二-boolean" class="headerlink" title="二 boolean"></a>二 boolean</h1><h2 id="2-1-概述-1"><a href="#2-1-概述-1" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><table>
<thead>
<tr>
<th>项</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code>（布尔值）</td>
<td><code>false, true</code></td>
</tr>
<tr>
<td><code>Falsy</code>（类假值）</td>
<td><code>false, 0, &#39;&#39;, undefined, null, NaN</code></td>
</tr>
<tr>
<td><code>Truthy</code>（类真值）</td>
<td>非 <code>Falsy</code> 的值</td>
</tr>
</tbody></table>
<ol>
<li>隐式转换<ul>
<li><code>Falsy</code> 可以隐式转换为 <code>false</code>；<code>Truthy</code> 可以隐式转换为 <code>true</code></li>
<li>注意：值和布尔值是不同的概念</li>
</ul>
</li>
<li>显式转换<ol>
<li><code>Boolean()</code></li>
<li><code>!!</code></li>
<li><code>new Boolean()</code><ul>
<li>不推荐，因为返回一个对象，而对象是 <code>Truthy</code> 转为布尔值必为 <code>true</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="2-2-包装类（Boolean）"><a href="#2-2-包装类（Boolean）" class="headerlink" title="2.2 包装类（Boolean）"></a>2.2 包装类（Boolean）</h2><h3 id="1-构造函数-1"><a href="#1-构造函数-1" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new Boolean([value])</code></td>
<td>构造函数</td>
<td>创建一个 <code>Boolean</code> 对象</td>
</tr>
<tr>
<td><code>Boolean([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个布尔值</td>
</tr>
</tbody></table>
<h3 id="2-原型方法-Boolean-prototype"><a href="#2-原型方法-Boolean-prototype" class="headerlink" title="2 原型方法 Boolean.prototype."></a>2 原型方法 <code>Boolean.prototype.</code></h3><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toString()</code></td>
<td>返回布尔值的字符串形式</td>
</tr>
<tr>
<td><code>valueOf()</code></td>
<td>返回布尔值</td>
</tr>
</tbody></table>
<h1 id="三-string"><a href="#三-string" class="headerlink" title="三 string"></a>三 string</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="1-字符串字面量"><a href="#1-字符串字面量" class="headerlink" title="1 字符串字面量"></a>1 字符串字面量</h3><table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;&quot;</code> <code>&#39;&#39;</code></td>
<td>单/双引号，特殊字符使用 <code>\</code> 转义</td>
</tr>
<tr>
<td><code>&#96;&#96;</code></td>
<td>反引号，模板字面量，</td>
</tr>
<tr>
<td><code>\uxxxx</code></td>
<td>只限 Unicode 编码在 <code>\u0000~\uFFFF</code>（0-65535）之间的字符</td>
</tr>
<tr>
<td><code>\u&#123;xxxx&#125;</code></td>
<td>大于<code>\uFFFF</code>的字符也能正确表示</td>
</tr>
</tbody></table>
<h3 id="2-字符串模板字面量"><a href="#2-字符串模板字面量" class="headerlink" title="2 字符串模板字面量"></a>2 字符串模板字面量</h3><ol>
<li><p>使用 `` 符号（可以嵌套）来编写字符串，称之为模板字符串</p>
</li>
<li><p>特殊字符（除了反引号自身需要<code>\</code>转义）可以直接使用</p>
</li>
<li><p>在模板字符串中，可以通过 ${expression} 来嵌入动态的内容，且模板字符串会被动态内容分割成多个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = &#x27;xiaoming&#x27;, age = 18;</span><br><span class="line">`hello$&#123;name&#125;,ni$&#123;age&#125;了吗`; </span><br><span class="line">// 分割成多个元素</span><br><span class="line">1：[&#x27;hello&#x27;, &#x27;,ni&#x27;, &#x27;了吗&#x27;]</span><br><span class="line">2：&#x27;xiaoming&#x27;</span><br><span class="line">3：18</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个元素是数组，数组元素是被动态内容分割的一个个标签模板字符串的片段</li>
<li>后面的元素是一个个标签模板字符串传入动态内容</li>
</ol>
</li>
<li><p>标签模板字符串（Tagged Template Literals）：另一种调用函数的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1 内置函数</span><br><span class="line">alert`hello`;</span><br><span class="line"></span><br><span class="line">// 2 自定义函数</span><br><span class="line">function myTag (strings, ...values)&#123;&#125;</span><br><span class="line">myTag`hello`</span><br><span class="line"></span><br><span class="line">// 3 带动态内容</span><br><span class="line">let name = &#x27;xiaoming&#x27;, age = 18;</span><br><span class="line">alert`hello$&#123;name&#125;,ni$&#123;age&#125;了吗`; </span><br><span class="line">// 相当于</span><br><span class="line">alert ([&#x27;hello&#x27;, &#x27;,ni&#x27;, &#x27;了吗&#x27;], &#x27;xiaoming&#x27;, 18); </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-2-包装类（String）"><a href="#3-2-包装类（String）" class="headerlink" title="3.2 包装类（String）"></a>3.2 包装类（String）</h2><h3 id="1-构造函数-2"><a href="#1-构造函数-2" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>new String([value])</code></td>
<td>构造函数</td>
<td>创建一个 <code>String</code> 对象</td>
</tr>
<tr>
<td><code>String([value])</code></td>
<td>类型转换函数</td>
<td>将 <code>value</code> 转成一个字符串</td>
</tr>
</tbody></table>
<ul>
<li>由于字符串的不可变性，字符串中的所有方法都不改变原字符串</li>
</ul>
<h3 id="2-实例属性"><a href="#2-实例属性" class="headerlink" title="2 实例属性"></a>2 实例属性</h3><table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>字符数</td>
</tr>
</tbody></table>
<h3 id="3-静态方法-1"><a href="#3-静态方法-1" class="headerlink" title="3 静态方法"></a>3 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>String.fromCharCode(charCode1, ..., charCodeN)</code></td>
<td>返回使用指定的 Unicode 编码创建的字符串，不能识别大于<code>0xFFFF</code>的字符</td>
</tr>
<tr>
<td><code>String.fromCodePoint(num1[, ...[, numN]])</code></td>
<td>返回使用指定的 Unicode 编码创建的字符串，识别大于<code>0xFFFF</code>的字符</td>
</tr>
<tr>
<td><code>String.raw&#96;templateString&#96;</code></td>
<td>返回模板字符串的原始字符串</td>
</tr>
</tbody></table>
<h3 id="4-原型方法-String-prototype"><a href="#4-原型方法-String-prototype" class="headerlink" title="4 原型方法 String.prototype."></a>4 原型方法 <code>String.prototype.</code></h3><h4 id="1-查"><a href="#1-查" class="headerlink" title="1 查"></a>1 查</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>charAt(index)</code></td>
<td>返回指定索引的字符</td>
</tr>
<tr>
<td><code>str[index]</code></td>
<td>等效于 <code>charAt(index)</code></td>
</tr>
<tr>
<td><code>charCodeAt(index)</code></td>
<td>返回指定索引字符的 Unicode 码，只能获取两个字节的字符</td>
</tr>
<tr>
<td><code>codePointAt(index)</code></td>
<td>返回指定索引字符的 Unicode 码</td>
</tr>
<tr>
<td><code>indexOf(searchValue[, fromIndex])</code></td>
<td>返回第一次出现的索引，未找到返回 <code>-1</code></td>
</tr>
<tr>
<td><code>lastIndexOf(searchValue[, fromIndex])</code></td>
<td>返回从后往前第一次出现的索引，未找到返回 <code>-1</code></td>
</tr>
</tbody></table>
<h4 id="2-获取"><a href="#2-获取" class="headerlink" title="2 获取"></a>2 获取</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>valueOf()</code></td>
<td>返回字符串对象的原始字符串</td>
</tr>
<tr>
<td><code>repeat(count)</code></td>
<td>返回当前字符串重复 <code>count</code> 次组成的新字符串</td>
</tr>
<tr>
<td><code>concat(str1, str2[, ..., strN])</code></td>
<td>连接字符串并返回</td>
</tr>
<tr>
<td><code>slice(beginIndex[, endIndex])</code></td>
<td>提取 <code>[begin,end)</code> 索引之间的字符串并返回，索引可以为负</td>
</tr>
<tr>
<td><code>substring(beginIndex[, endIndex])</code></td>
<td>提取 <code>[begin,end)</code> 索引之间的字符串并返回，</td>
</tr>
</tbody></table>
<h4 id="3-改"><a href="#3-改" class="headerlink" title="3 改"></a>3 改</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toLowerCase()</code></td>
<td>转小写</td>
</tr>
<tr>
<td><code>toUpperCase()</code></td>
<td>转大写</td>
</tr>
<tr>
<td><code>trim()</code></td>
<td>去除字符串两端的空格</td>
</tr>
<tr>
<td><code>trimStart()</code></td>
<td>去除字符串左侧的空格</td>
</tr>
<tr>
<td><code>trimEnd</code></td>
<td>去除字符串右侧的空格</td>
</tr>
<tr>
<td><code>padStart(targetLength [, padString])</code></td>
<td>以指定字符串 <code>padString</code> 在原字符串开头补充，以达到目标长度 <code>targetLength</code></td>
</tr>
<tr>
<td><code>padEnd(targetLength [, padString])</code></td>
<td>以指定字符串 <code>padString</code> 在原字符串末尾补充，以达到目标长度 <code>targetLength</code></td>
</tr>
</tbody></table>
<h4 id="4-判断"><a href="#4-判断" class="headerlink" title="4 判断"></a>4 判断</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>includes(searchString[, fromIndex])</code></td>
<td>判断是否包含指定字符串</td>
</tr>
<tr>
<td><code>startsWith(searchString[, fromIndex])</code></td>
<td>判断是否以指定字符串开头</td>
</tr>
<tr>
<td><code>endsWith(searchString[, length])</code></td>
<td>判断是否以指定字符串结尾，<code>length</code> 表示只判断原字符串指定长度</td>
</tr>
</tbody></table>
<h4 id="5-正则"><a href="#5-正则" class="headerlink" title="5 正则"></a>5 正则</h4><table>
<thead>
<tr>
<th>原型方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>split([separator[, limit]])</code></td>
<td>按照给定规则分割字符串，返回一个由分割出来的子字符串以指定分隔符组成的数组</td>
</tr>
<tr>
<td><code>search(regexp)</code></td>
<td>返回首次匹配项的索引，无匹配返回 <code>-1</code></td>
</tr>
<tr>
<td><code>match(regexp)</code></td>
<td>正则有 <code>g</code>，则返回所有匹配结果的数组（无附加属性），正则无 <code>g</code>，则返回只有第一个匹配结果的数组（有附加属性），无匹配返回 <code>null</code></td>
</tr>
<tr>
<td><code>matchAll(regexp)</code></td>
<td>返回所有匹配结果的迭代器（包含附加属性）</td>
</tr>
</tbody></table>
<h4 id="6-替换"><a href="#6-替换" class="headerlink" title="6 替换"></a>6 替换</h4><ul>
<li><code>replace(regexp|substr, newSubStr|function)</code><ul>
<li><code>regexp|substr</code><ul>
<li>正则匹配的内容或者指定的内容</li>
</ul>
</li>
<li><code>newSubStr</code><ul>
<li>使用新的字符串替换，替换时可以插入特殊变量</li>
</ul>
</li>
<li><code>function</code><ul>
<li>使用函数返回的字符串替换</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">特殊变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$$</code></td>
<td>插入一个 “$”</td>
</tr>
<tr>
<td align="center"><code>$&amp;</code></td>
<td>插入匹配的子串</td>
</tr>
<tr>
<td align="center">$`</td>
<td>插入当前匹配的子串左边的内容</td>
</tr>
<tr>
<td align="center"><code>$&#39;</code></td>
<td>插入当前匹配的子串右边的内容</td>
</tr>
<tr>
<td align="center"><code>$n</code></td>
<td>如果第一个参数是RegExp对象，表示插入第n组的内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">函数参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>match</code></td>
<td>匹配的子串。（对应<code>$&amp;</code>。）</td>
</tr>
<tr>
<td align="center"><code>p1,p2,...</code></td>
<td>如果第一个参数是RegExp对象，表示第n组的内容（对应<code>$n</code>）</td>
</tr>
<tr>
<td align="center"><code>offset</code></td>
<td>匹配到的子字符串在原字符串中起始索引</td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td>被匹配的原字符串</td>
</tr>
<tr>
<td align="center"><code>NamedCaptureGroup</code></td>
<td>命名捕获组匹配的对象</td>
</tr>
</tbody></table>
<h1 id="四-undefined"><a href="#四-undefined" class="headerlink" title="四 undefined"></a>四 undefined</h1><ol>
<li><code>undefined</code> 是一种类型，且只有一个值 <code>undefined</code></li>
<li>一个变量没有指定类型（没有赋值则不能确定类型），则默认为 <code>undefined</code> 类型，其值也是 <code>undefined</code><ul>
<li>变量或者对象属性没有赋值，默认值为 <code>undefined</code></li>
<li>调用函数时，没有传值的参数默认值为 <code>undefined</code></li>
<li>函数没有返回值时，默认返回 <code>undefined</code></li>
</ul>
</li>
</ol>
<h1 id="五-symbol"><a href="#五-symbol" class="headerlink" title="五 symbol"></a>五 symbol</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ol>
<li>symbol 的值是唯一的，独一无二的，不会重复的</li>
<li>之前对象属性名只能是字符串，现在也可以是 symbol</li>
<li>symbol 值作为对象属性名时，不能用点运算符，只能使用<code>[]</code><ol>
<li>不会被<code>for...in for... of</code>遍历到</li>
<li>不会被 <code>Object.keys() Object.getOwnPropertyNames() JSON.stringify()</code> 返回</li>
<li>使用<code>Object.getOwnPropertySymbols()</code>可以获取</li>
</ol>
</li>
<li>symbol 值不能与其他类型的值进行运算，可以转为字符串和布尔值</li>
</ol>
<h2 id="5-2-包装类（Symbol）"><a href="#5-2-包装类（Symbol）" class="headerlink" title="5.2 包装类（Symbol）"></a>5.2 包装类（Symbol）</h2><h3 id="1-构造函数-3"><a href="#1-构造函数-3" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol([description])</code></td>
<td>返回一个唯一的 <code>symbol</code> 值，不会放入全局 <code>symbol</code> 注册表，<code>description</code>：只是描述，不影响 <code>symbol</code> 值</td>
</tr>
<tr>
<td><code>new Symbol()</code></td>
<td>不支持此语法</td>
</tr>
</tbody></table>
<h3 id="2-静态属性-1"><a href="#2-静态属性-1" class="headerlink" title="2 静态属性"></a>2 静态属性</h3><ul>
<li>ES6 提供了 11 个内置的 <code>symbol</code> 值，指向语言内部使用的方法</li>
</ul>
<table>
<thead>
<tr>
<th>静态属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol.hasInstance</code></td>
<td><code>A instanceof B</code> 实际调用的是 <code>B[Symbol.hasInstance](A)</code></td>
</tr>
<tr>
<td><code>Symbol.iterator</code></td>
<td>指向一个返回对象迭代器的方法, <code>Obj[Symbol.iterator]()</code> 获取此方法并执行，返回对象的迭代器，被 <code>for... of</code> 使用</td>
</tr>
</tbody></table>
<h3 id="3-实例属性"><a href="#3-实例属性" class="headerlink" title="3 实例属性"></a>3 实例属性</h3><table>
<thead>
<tr>
<th>实例属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>description</code></td>
<td>只读属性，返回 Symbol 对象的可选的描述字符串</td>
</tr>
</tbody></table>
<h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4 静态方法"></a>4 静态方法</h3><table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Symbol.for(key)</code></td>
<td>根据 <code>key</code> 从全局 <code>symbol</code> 注册表查询，找到则返回，否则创建一个与 <code>key</code> 关联的 <code>symbol</code> 值并放入全局 <code>symbol</code>注册表</td>
</tr>
<tr>
<td><code>Symbol.keyFor(sym)</code></td>
<td>获取全局 <code>symbol</code> 注册表中与指定 <code>symbole</code> 值关联的 <code>key</code></td>
</tr>
</tbody></table>
<h1 id="六-BigInt"><a href="#六-BigInt" class="headerlink" title="六 BigInt"></a>六 BigInt</h1><ol>
<li> 在早期的 JavaScript 中，大于 MAX_SAFE_INTEGER 的数值，表示的可能是不正确的</li>
<li> ES11中，引入了新的数据类型 BigInt，用于表示大的整数</li>
<li> BitInt 的表示方法是在数值的后面加上 n，如 <code>10000000n</code></li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/14/01-JS%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/14/01-JS%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">01-JS语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-14 19:50:53 / 修改时间：20:01:44" itemprop="dateCreated datePublished" datetime="2022-02-14T19:50:53+08:00">2022-02-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-JavaScript-机制"><a href="#一-JavaScript-机制" class="headerlink" title="一 JavaScript 机制"></a>一 JavaScript 机制</h1><h2 id="1-1-浏览器"><a href="#1-1-浏览器" class="headerlink" title="1.1 浏览器"></a>1.1 浏览器</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p>浏览器由两部分组成</p>
<ul>
<li>浏览器内核（渲染引擎）：负责 Html 和 CSS 解析、布局、渲染等</li>
<li>JavaScript 引擎：专门处理 JavaScript 脚本的虚拟机，也称 JS 解释器，负责将 JS 代码翻译成二进制指令交给 CPU 执行</li>
</ul>
</li>
<li><p>浏览器内核</p>
<ol>
<li>Gecko：早期被 Netscape 和 Mozilla Firefox 浏览器浏览器使用</li>
<li>Trident：微软开发，被 IE4~IE11 浏览器使用，但是Edge浏览器已经转向 Blink</li>
<li>Webkit：苹果基于 KHTML 开发、开源的，用于Safari，Google Chrome之前也在使用</li>
<li>Blink：是 Webkit 的一个分支，Google 开发，目前应用于Google Chrome、Edge、Opera 等</li>
</ol>
</li>
<li><p>JavaScript 引擎</p>
<ol>
<li>SpiderMonkey：第一款 JavaScript引擎，由 Brendan Eich 开发（也就是 JavaScript 作者）</li>
<li>Chakra：微软开发，用于 IE 浏览器</li>
<li>JavaScriptCore：WebKit 中的 JavaScript 引擎，Apple 公司开发</li>
<li>V8：Google 开发的强大 JavaScript 引擎</li>
</ol>
</li>
</ol>
<h3 id="2-浏览器渲染过程"><a href="#2-浏览器渲染过程" class="headerlink" title="2 浏览器渲染过程"></a>2 浏览器渲染过程</h3><p><img src="https://gitee.com/an3/mbp/raw/master/javascript/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png"></p>
<ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>css 和 html 是并行加载的，过程中如果遇到 css 或者 img，则会向浏览器返回一个请求，待资源返回后，将其添加到 dom 的相应位置中</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎（原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。）</li>
<li>如果 <code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，继续往下解析 HTML 网页</li>
</ol>
<h3 id="3-V8-引擎"><a href="#3-V8-引擎" class="headerlink" title="3 V8 引擎"></a>3 V8 引擎</h3><p><img src="https://gitee.com/an3/mbp/raw/master/javascript/V8.svg"></p>
<p><img src="D:\唯手熟尔\02-CS\03-招式\01-前端\03-JavaScript\img\V8.png"></p>
<ol>
<li>Blink将源码交给V8引擎，Stream获取到源码并且进行编码转换</li>
<li>Scanner会进行词法分析（lexical analysis），词法分析会将代码转换成tokens</li>
<li>接下来tokens会被转换成 AST 树，经过 Parser 和 PreParser：<ol>
<li>Parser 就是直接将 tokens 转成 AST 树架构</li>
<li>PreParser 称之为预解析，因为并不是所有的 JavaScript 代码，在一开始时就会被执行。那么对所有的 JavaScript 代码进行解析，必然会影响网页的运行效率，所以 V8 引擎就实现了 Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对函数的全量解析是在函数被调用时才会进行</li>
</ol>
</li>
<li>生成 AST 树后，Ignition 是一个解释器，会将 AST 转换成 ByteCode（字节码），同时会收集 TurboFan 优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）</li>
<li>TurboFan 是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码<ul>
<li>如果一个函数被多次调用，那么就会被标记为热点函数，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能</li>
<li>机器码实际上也会被还原为 ByteCode，这是因为如果后续执行函数的过程中，类型发生了变化（比如sum函数原来执行的是 number类型，后来执行变成了string类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；</li>
</ul>
</li>
</ol>
<h2 id="1-2-JavaScript-的执行过程"><a href="#1-2-JavaScript-的执行过程" class="headerlink" title="1.2 JavaScript 的执行过程"></a>1.2 JavaScript 的执行过程</h2><h3 id="1-初始化全局对象"><a href="#1-初始化全局对象" class="headerlink" title="1 初始化全局对象"></a>1 初始化全局对象</h3><table>
<thead>
<tr>
<th>环境</th>
<th>早期全局对象</th>
<th>ES2020 全局对象</th>
</tr>
</thead>
<tbody><tr>
<td>浏览器</td>
<td>window，self</td>
<td>globalThis</td>
</tr>
<tr>
<td>Node</td>
<td>global</td>
<td>globalThis</td>
</tr>
<tr>
<td>Web Worker</td>
<td>self</td>
<td>globalThis</td>
</tr>
</tbody></table>
<ul>
<li>JS 引擎在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）<ol>
<li>GO 可以被所有作用域访问</li>
<li>GO 包含 Date、Array、String、Number、setTimeout、setInterval 等等</li>
<li>GO 还包含一个属性指向自己，如浏览器环境的 window</li>
</ol>
</li>
</ul>
<h3 id="2-执行上下文栈（调用栈）"><a href="#2-执行上下文栈（调用栈）" class="headerlink" title="2 执行上下文栈（调用栈）"></a>2 执行上下文栈（调用栈）</h3><p><img src="https://gitee.com/an3/mbp/raw/master/javascript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png"></p>
<ol>
<li>JS 引擎内部有一个执行上下文栈（Execution Context Stack，ECS），它是用于执行代码的调用栈。栈中以执行上下文为单元执行代码<ol>
<li>全局的代码为了执行会构建一个全局执行上下文（Global Execution Context，GEC），GEC 包含：<ol>
<li>VO/VE<ol>
<li>在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，但是并不会赋值；这个过程也称之为变量的作用域提升（hoisting）</li>
<li>VO/VE 其实就是 GO</li>
</ol>
</li>
<li>要执行的代码：在代码执行中，对变量赋值，或者执行其他的函数</li>
</ol>
</li>
<li>函数执行时会构建一个函数执行上下文（Functional Execution Context，FEC），FEC 包含：<ol>
<li>VO/VE<ol>
<li>在函数解析成为 AST 树结构时，会创建一个 Activation Object（AO 中包含形参、arguments、函数中定义的函数和变量）</li>
<li>VO/VE 其实就是 AO</li>
</ol>
</li>
<li>作用域链：由 VO/VE 和父级 VO/VE 组成，查找时会一层层查找</li>
<li>this 绑定的值</li>
<li>要执行的代码</li>
</ol>
</li>
</ol>
</li>
<li>新规范的 VE<ol>
<li>VE 指向了一个名叫 VariableMap 的 HashMap </li>
<li>var/let/const 声明的变量都存储在 VariableMap 中的，另外 var 声明的还会在 window 中添加一份，且修改时，两个地方都会修改（兼容以前）</li>
</ol>
</li>
</ol>
<h1 id="二-作用域"><a href="#二-作用域" class="headerlink" title="二 作用域"></a>二 作用域</h1><h2 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h2><ol>
<li>全局作用域：当前或外部 <code>.js</code> 文件全局</li>
<li>函数作用域：函数内部</li>
<li>块作用域：<ul>
<li>ES 6 之后才有</li>
<li>注意：对象字面量没有作用域，不属于块级作用域</li>
</ul>
</li>
<li>参数作用域：当函数形参有默认值时，会增加一个参数作用域</li>
</ol>
<h2 id="2-2-闭包-closure"><a href="#2-2-闭包-closure" class="headerlink" title="2.2 闭包 (closure)"></a>2.2 闭包 (closure)</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）</p>
<ol>
<li>从广义的角度来说：JavaScript中的函数都是闭包</li>
<li>从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包</li>
</ol>
</li>
<li><p>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 <strong>自由变量</strong> 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行</p>
</li>
<li><p>一个函数声明在某个作用域内，则这个函数与它能在此作用域中所有能访问的变量构成了闭包</p>
<ol>
<li>当函数在此作用域内执行时，它当然可以访问此作用域中的内容</li>
<li>当函数在此作用域外执行时，它依然可以访问此作用域中的内容，正常来说，在某个作用域外部是不能访问内部的内容的，能访问的原因就是闭包。</li>
</ol>
</li>
<li><p>闭包可以让函数在其声明所在作用域外部执行时访问到内部的变量，延长了变量的生命周期和作用范围</p>
</li>
</ol>
<h3 id="2-闭包的访问过程"><a href="#2-闭包的访问过程" class="headerlink" title="2 闭包的访问过程"></a>2 闭包的访问过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">	int num = 10;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		console.log(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const inner = outer();</span><br><span class="line">inner();</span><br><span class="line"></span><br><span class="line">1 outer 执行完毕后，它的 FEC 已经弹栈，但它的 AO 对象很明显没有被 GC 销毁，因为 inner 中依然能访问到 num</span><br><span class="line">2 AO 没有被 GC 销毁，说明还有引用，其实堆中每个函数对象中除了函数体之外，还有一个引用指向了父作用域的 AO</span><br><span class="line">3 既然 AO 没有被销毁，而函数中又有指向，执行时当然能够访问</span><br></pre></td></tr></table></figure>

<h3 id="3-闭包的内存泄露"><a href="#3-闭包的内存泄露" class="headerlink" title="3 闭包的内存泄露"></a>3 闭包的内存泄露</h3><p><img src="https://gitee.com/an3/mbp/raw/master/javascript/%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.png"></p>
<ol>
<li><p>函数在堆内存中会存储两部分内容</p>
<ol>
<li>父作用域（即指向父作用域的 AO 对象或 GO 对象 ）</li>
<li>函数体</li>
</ol>
</li>
<li><p>如图中，在代码执行完毕后，bar 函数的 AO 对象已经不可达，会被销毁，而 foo 函数的 AO 对象依然可达，不能销毁</p>
<ol>
<li>如果以后还会调用 fn 函数，当然最好</li>
<li>若之后 fn 不会再被使用，而 foo 函数的 AO 对象却不能销毁，就造成了内存泄漏</li>
</ol>
</li>
<li><p>AO 对象不会被销毁时，ECMA规范中 AO 中的所有变量都不会被销毁，但是 V8 引擎会做一些优化，将用不到的变量销毁掉</p>
</li>
</ol>
<h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4 应用"></a>4 应用</h3><h4 id="1-事件"><a href="#1-事件" class="headerlink" title="1 事件"></a>1 事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有 5 个 li ，添加点击事件，打印索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i); <span class="comment">// 最终结果每个 li 都打印 4，因为循环是同步的，而点击事件是异步的</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用闭包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">		lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 立即执行函数是一个单独作用域</span></span><br><span class="line"><span class="comment">// 2. 事件处理函数和立即执行函数中的局部变量 index 形成了闭包</span></span><br><span class="line"><span class="comment">// 3 var 改成 let 也行</span></span><br></pre></td></tr></table></figure>

<h4 id="2-定时任务"><a href="#2-定时任务" class="headerlink" title="2 定时任务"></a>2 定时任务</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);<span class="comment">// 最终结果都打印 4，因为循环是同步的，而定时任务是异步的</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用闭包------</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(index);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-this-的绑定"><a href="#2-3-this-的绑定" class="headerlink" title="2.3 this 的绑定"></a>2.3 this 的绑定</h2><h3 id="1-全局中"><a href="#1-全局中" class="headerlink" title="1 全局中"></a>1 全局中</h3><ol>
<li>严格模式：this 指向 undefined</li>
<li>非严格模式：this 指向 window（浏览器环境）</li>
</ol>
<h3 id="2-函数中"><a href="#2-函数中" class="headerlink" title="2 函数中"></a>2 函数中</h3><h4 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h4><ol>
<li>this 的绑定和函数定义的位置（编写的位置）没有关系</li>
<li>this 的绑定和函数调用方式以及调用的位置有关系</li>
<li>函数在调用时，JS 会默认给 this 绑定一个值</li>
<li>this是在运行时被绑定的</li>
</ol>
<h4 id="2-绑定规则（优先级：低-→-高）"><a href="#2-绑定规则（优先级：低-→-高）" class="headerlink" title="2 绑定规则（优先级：低 → 高）"></a>2 绑定规则（优先级：低 → 高）</h4><ol>
<li>默认绑定：<ul>
<li>独立函数调用（函数没有被绑定到某个对象上进行调用，与定义无关，即使这个函数定义在对象上却没有通过对象调用依然是独立函数调用）<ul>
<li>普通函数</li>
<li>回调函数</li>
<li>立即执行函数</li>
<li>内联事件处理函数</li>
<li>setTimeout / setInterval</li>
<li>数组的 forEach/find/map/filter… 有参数可以指定 this 的函数，但默认 this 绑定的是 window</li>
<li>…</li>
</ul>
</li>
<li>this 指向 window</li>
</ul>
</li>
<li>隐式绑定<ul>
<li>通过某个对象进行调用（此对象内部必须有此函数）</li>
<li>this 指向调用函数的对象</li>
</ul>
</li>
<li>显式绑定<ul>
<li>call 和 apply 在执行函数时，可以指定 this 的绑定</li>
<li>bind 会返回一个指定永久指定 this 绑定的原函数的副本</li>
<li>如果在显式绑定中，传入一个 null 或者 undefined，那么这个显式绑定会被忽略，使用默认绑定</li>
</ul>
</li>
<li>new绑定<ul>
<li>JavaScript 中的函数可以当做一个类的构造函数来使用，也就是使用 new 关键字</li>
<li>this 指向新创建的对象</li>
</ul>
</li>
<li>特殊（箭头函数）<ol>
<li>箭头函数不会绑定 this、arguments等属性，this 与箭头函数所在作用域的 this 指向一致</li>
<li>也就是说不能通过箭头函数自己改变 this，想改就改它父作用域的 this</li>
</ol>
</li>
</ol>
<h2 id="2-4-严格模式"><a href="#2-4-严格模式" class="headerlink" title="2.4 严格模式"></a>2.4 严格模式</h2><h3 id="1-启用"><a href="#1-启用" class="headerlink" title="1 启用"></a>1 启用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;use strict;&quot;</span></span><br><span class="line"><span class="comment">// 1 放在脚本文件的第一行，整个脚本都将以严格模式运行</span></span><br><span class="line"><span class="comment">// 2 放在函数体的第一行，则整个函数以严格模式运行</span></span><br></pre></td></tr></table></figure>

<h3 id="2-严格模式中的变化"><a href="#2-严格模式中的变化" class="headerlink" title="2 严格模式中的变化"></a>2 严格模式中的变化</h3><h4 id="1-显式报错"><a href="#1-显式报错" class="headerlink" title="1 显式报错"></a>1 显式报错</h4><ol>
<li>严格模式会使引起静默失败(silently fail，不报错也没有任何效果)的赋值操作抛出异常，如只读属性的写操作，不可扩展对象扩展操作</li>
<li>严格模式下，试图删除不可删除的属性时会抛出异常</li>
<li>严格模式下禁止对象属性重名</li>
<li>严格模式下禁止函数参数重名</li>
<li>严格模式禁止八进制数字语法</li>
</ol>
<h4 id="2-安全措施"><a href="#2-安全措施" class="headerlink" title="2 安全措施"></a>2 安全措施</h4><ol>
<li>严格模式下，变量必须先声明，然后再使用</li>
<li>禁止 this 关键字指向全局对象 <code>window</code></li>
<li>严格模式禁止删除声明变量</li>
</ol>
<h4 id="3-静态绑定"><a href="#3-静态绑定" class="headerlink" title="3 静态绑定"></a>3 静态绑定</h4><ol>
<li>js允许动态绑定，即属性或方法属于哪个对象不是编译时确定的，而是在运行时确定</li>
<li>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定，即编译时就确定属性或方法属于哪个对象。</li>
</ol>
<h4 id="4-其它"><a href="#4-其它" class="headerlink" title="4 其它"></a>4 其它</h4><ol>
<li>严格模式禁用 <code>with</code>语句</li>
<li>创设 eval 作用域<ul>
<li>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域。</li>
<li>严格模式下，eval语句本身就是一个作用域，即eval所生成的变量只能用于eval内部</li>
</ul>
</li>
<li>arguments 不再追踪参数的变化<ul>
<li>变量arguments代表函数的参数。</li>
<li>严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系</li>
</ul>
</li>
</ol>
<h1 id="三-基础语法"><a href="#三-基础语法" class="headerlink" title="三 基础语法"></a>三 基础语法</h1><h2 id="3-1-注释"><a href="#3-1-注释" class="headerlink" title="3.1 注释"></a>3.1 注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ 单行注释 /</span><br><span class="line"></span><br><span class="line">/* 多行注释，不能嵌套 */</span><br></pre></td></tr></table></figure>

<h2 id="3-2-变量"><a href="#3-2-变量" class="headerlink" title="3.2 变量"></a>3.2 变量</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li><p>变量的声明和赋值，是分开的两个步骤</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;  </span><br><span class="line"><span class="comment">// 其实是下边两步</span></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>同一条声明语句中可以声明多个变量</p>
</li>
<li><p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p>
</li>
<li><p>变量标识符命名规则</p>
<ol>
<li><code>A-Za-z</code> <code>0-9</code> <code>_</code> <code>$</code></li>
<li>不能用数字开头</li>
<li>不能使用 js 关键字和保留字</li>
</ol>
</li>
</ol>
<h3 id="2-声明关建字"><a href="#2-声明关建字" class="headerlink" title="2 声明关建字"></a>2 声明关建字</h3><table>
<thead>
<tr>
<th align="center">关键字</th>
<th>初始化</th>
<th>变量提升</th>
<th>作用域</th>
<th>window</th>
<th>同一作用域重复声明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>var</code></td>
<td>可选</td>
<td>有</td>
<td><code>全局，函数</code></td>
<td>全局声明会添加到 <code>window</code> 对象</td>
<td>可以，后者覆盖前者</td>
</tr>
<tr>
<td align="center"><code>let</code></td>
<td>可选</td>
<td>无</td>
<td><code>全局，函数，块</code></td>
<td>全局声明不会添加到 <code>window</code> 对象</td>
<td>不能</td>
</tr>
<tr>
<td align="center"><code>const</code></td>
<td>必须</td>
<td>无</td>
<td><code>全局，函数，块</code></td>
<td>全局声明不会添加到 <code>window</code> 对象</td>
<td>不能</td>
</tr>
</tbody></table>
<ol>
<li><p>JS 引擎运行分为两步：预解析和代码执行</p>
</li>
<li><p>预解析：将脚本中所有 <code>var</code> 和 <code>function</code> 语句提升到其作用域的最前面（hoisting）</p>
<ol>
<li><p>let/const 声明的变量会在包含它们的词法环境被实例化时创建，但直到词法绑定被求值时才可以访问，</p>
<ol>
<li>let / cosnt 声明的变量也会创建，只是不能访问</li>
<li>从作用域开始到声明语句之间区域，如果使用声明的变量就会导致 <code>ReferenceError</code>，这块区域称为暂时性死区 TDZ <code>temporal dead zone</code></li>
</ol>
</li>
<li><p>变量提升 <code>var</code>：将变量的声明提升到其作用域最前面，赋值操作不会提升</p>
</li>
<li><p>函数提升 <code>function</code>：将函数的声明提升到其作用域最前面</p>
</li>
</ol>
</li>
<li><p>块级作用域</p>
<ol>
<li>对 let/const/function/class 声明有效，对 var 无效</li>
<li>标准中 function 的声明是有效的，但有的浏览器为了兼容可能会依然无效</li>
</ol>
</li>
<li><p>for 循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">	setTimeout(function()&#123;</span><br><span class="line">		console.log(i);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">// var 没有快作用域，会声明在全局，所以最后每轮打印的都是 3</span><br><span class="line">// 解析后的伪代码，i 都是同一个 最后值为 3</span><br><span class="line">&#123;var i = 0; 逻辑代码&#125;</span><br><span class="line">&#123;var i = 1; 逻辑代码&#125;</span><br><span class="line">&#123;var i = 2; 逻辑代码&#125;</span><br><span class="line"></span><br><span class="line">for(let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">	setTimeout(function()&#123;</span><br><span class="line">		console.log(i);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 解析后的伪代码，每个逻辑代码访问的都是自己的 i</span><br><span class="line">&#123;let i = 0; 逻辑代码&#125;</span><br><span class="line">&#123;let i = 1; 逻辑代码&#125;</span><br><span class="line">&#123;let i = 2; 逻辑代码&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>特殊情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 不使用关键字直接使用变量时，会添加到全局对象中</span><br><span class="line">num = 1;</span><br><span class="line"></span><br><span class="line">2 </span><br><span class="line">var a = b = 10;</span><br><span class="line">会转换成以下代码</span><br><span class="line">b = 10;</span><br><span class="line">var a = b;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-3-运算符"><a href="#3-3-运算符" class="headerlink" title="3.3 运算符"></a>3.3 运算符</h2><h3 id="1-赋值运算符"><a href="#1-赋值运算符" class="headerlink" title="1 赋值运算符"></a>1 赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>等价于</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>赋值</td>
<td><code>x = y</code></td>
<td><code>x = y</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加赋值</td>
<td><code>x += y</code></td>
<td><code>x = x + y</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减赋值</td>
<td><code>x -= y</code></td>
<td><code>x = x - y</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘赋值</td>
<td><code>x *= y</code></td>
<td><code>x = x * y</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除赋值</td>
<td><code>x /= y</code></td>
<td><code>x = x / y</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>模赋值</td>
<td><code>x %= y</code></td>
<td><code>x = x % y</code></td>
</tr>
<tr>
<td><code>**=</code></td>
<td>指数赋值</td>
<td><code>x **= y</code></td>
<td><code>x = x ** y</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>左移赋值</td>
<td><code>x &lt;&lt;= y</code></td>
<td><code>x = x &lt;&lt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>右移赋值</td>
<td><code>x &gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;=</code></td>
<td>无符号右移赋值</td>
<td><code>x &gt;&gt;&gt;= y</code></td>
<td><code>x = x &gt;&gt;&gt; y</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>按位与赋值</td>
<td><code>x &amp;= y</code></td>
<td><code>x = x &amp; y</code></td>
</tr>
<tr>
<td><code>&#124;=</code></td>
<td>按位或赋值</td>
<td><code>x &#124;= y</code></td>
<td><code>x = x &#124; y</code></td>
</tr>
<tr>
<td><code>^=</code></td>
<td>按位异或赋值</td>
<td><code>x ^= y</code></td>
<td><code>x = x ^ y</code></td>
</tr>
<tr>
<td><code>&amp;&amp;=</code></td>
<td>逻辑与赋值</td>
<td><code>x &amp;&amp;= y</code></td>
<td><code>x = x &amp;&amp; y</code></td>
</tr>
<tr>
<td>`</td>
<td></td>
<td>=`</td>
<td>逻辑或赋值</td>
</tr>
<tr>
<td><code>??=</code></td>
<td>逻辑空值合并赋值</td>
<td><code>x ??= y</code></td>
<td><code>x = x ?? y</code></td>
</tr>
</tbody></table>
<h3 id="2-算术运算符"><a href="#2-算术运算符" class="headerlink" title="2 算术运算符"></a>2 算术运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>x + y</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>x - y</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>x * y</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>x / y</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>求余</td>
<td><code>x % y</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>幂</td>
<td><code>x ** y</code></td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增</td>
<td><code>x++</code> 或 <code>++x</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减</td>
<td><code>x--</code> 或 <code>--x</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>一元正号</td>
<td><code>+x</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>一元负号</td>
<td><code>-x</code></td>
</tr>
</tbody></table>
<h4 id="1-加法"><a href="#1-加法" class="headerlink" title="1 加法"></a>1 加法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 遇到字符串会变成连接</span><br><span class="line">let s = &quot;xx&quot; + 2; //xx2</span><br><span class="line"></span><br><span class="line">2 对象会转为字符串</span><br><span class="line">let obj = &#123; p: 1 &#125;;</span><br><span class="line">obj + 2 // &quot;[object Object]2&quot;</span><br><span class="line">// obj.valueOf() 结果为&#123;p:1&#125;</span><br><span class="line">// obj.valueOf().toString() 结果为&quot;[object object]&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-一元加减"><a href="#2-一元加减" class="headerlink" title="2 一元加减"></a>2 一元加减</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 一元加号/减号运算符的作用在于可以将任何值转为数值</span><br><span class="line">+true // 1</span><br><span class="line">+[] // 0</span><br><span class="line">+&#123;&#125; // NaN</span><br></pre></td></tr></table></figure>

<h4 id="3-幂运算"><a href="#3-幂运算" class="headerlink" title="3 幂运算"></a>3 幂运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 ** 3 ** 2</span><br><span class="line">// 512 相当于 2 ** (3 ** 2) 即先求3的2次方=9 再求2的9次方</span><br><span class="line"></span><br><span class="line">1 前一个运算子是底数，后一个运算子是指数</span><br><span class="line">2 幂运算符是右结合：即多个指数运算符连用时，先进行最右边的计算。</span><br></pre></td></tr></table></figure>

<h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="3 比较运算符"></a>3 比较运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>x &gt; y</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>x &lt; y</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>x &gt;= y</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>x &lt;= y</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td>相等</td>
<td><code> x == y</code></td>
</tr>
<tr>
<td><code>===</code></td>
<td>严格相等</td>
<td><code>x === y</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不相等</td>
<td><code>x != y</code></td>
</tr>
<tr>
<td><code>!==</code></td>
<td>严格不相等</td>
<td><code>x !== y</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方式</th>
<th><code>NaN</code></th>
<th><code>undefined</code></th>
<th><code>null</code></th>
<th><code>+0 </code> 和 <code>-0</code></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>不等于任何值</td>
<td>等于 <code>undefined</code> 和 <code>null</code></td>
<td>等于 <code>undefined</code> 和 <code>null</code></td>
<td>相等</td>
<td>先进行类型转换，之后使用 <code>===</code> 比较</td>
</tr>
<tr>
<td><code>===</code></td>
<td>不等于任何值</td>
<td>等于 <code>undefined</code></td>
<td>等于 <code>null</code></td>
<td>相等</td>
<td>类型不同即为 <code>false</code></td>
</tr>
<tr>
<td><code>Object.is(value1, value2)</code></td>
<td>等于 <code>NaN</code></td>
<td>等于 <code>undefined</code></td>
<td>等于 <code>null</code></td>
<td>不相等</td>
<td>类型不同即为 <code>false</code></td>
</tr>
</tbody></table>
<h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4 逻辑运算符"></a>4 逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td><code>expr1 &amp;&amp; expr2</code></td>
<td>若 expr1 为 Truthy，则返回 expr2 的结果；否则直接返回 expr1 的结果，且不在计算 expr2（短路）</td>
</tr>
<tr>
<td><code>&#124;&#124;</code></td>
<td>逻辑或</td>
<td><code>expr1 &#124;&#124; expr2</code></td>
<td>若 expr1 为 Falsy，则返回 expr2 的结果；否则直接返回 expr1 的结果，且不在计算 expr2（短路）</td>
</tr>
<tr>
<td><code>??</code></td>
<td>空值合并操作符</td>
<td><code>expr1 ?? expr2</code></td>
<td>若 expr1 为 <code>null/undefined</code>，则返回 expr2 的结果；否则直接返回 expr1 的结果，且不在计算 expr2（短路）</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非</td>
<td><code>!expr</code></td>
<td>若 <code>expr</code> 为 <code>true</code>，则返回 <code>false</code>，否则，返回 <code>true</code></td>
</tr>
<tr>
<td><code>!!</code></td>
<td>双重非</td>
<td><code>!!expr</code></td>
<td>显式地将任意值强制转换为其对应的布尔值</td>
</tr>
</tbody></table>
<h3 id="5-按位运算符"><a href="#5-按位运算符" class="headerlink" title="5 按位运算符"></a>5 按位运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>运算式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>x &amp; y</code></td>
<td>有 0 则 0</td>
</tr>
<tr>
<td><code>&#124;</code></td>
<td>按位或</td>
<td><code>x &#124; y</code></td>
<td>有 1 则 1</td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位非</td>
<td><code>~x</code></td>
<td>1 变 0，0 变 1</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
<td><code>x ^ y</code></td>
<td>相同则 0，不同则 1</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>x &lt;&lt; y</code></td>
<td>舍去高位，低位补 0，相当于 <code>x * 2<sup>y</sup></code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>x &gt;&gt; y</code></td>
<td>舍去低位，正数高位补 0，负数高位补 1，相当于 <code>x / 2<sup>y</sup></code></td>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>无符号右移</td>
<td><code>x &gt;&gt;&gt; y</code></td>
<td>舍去低位，高位补 0，相当于 <code>x / 2<sup>y</sup></code></td>
</tr>
</tbody></table>
<h3 id="6-其它运算符"><a href="#6-其它运算符" class="headerlink" title="6 其它运算符"></a>6 其它运算符</h3><h4 id="1-三元运算符"><a href="#1-三元运算符" class="headerlink" title="1 三元运算符"></a>1 三元运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? exprIfTrue : exprIfFalse</span><br></pre></td></tr></table></figure>

<ol>
<li>若 <code>condition</code> 为 true，返回 <code>exprIfTrue</code> 的值，否则，返回 <code>exprIfFalse</code> 的值</li>
<li>和 <code>if else</code> 的区别：<ol>
<li>if…else是语句，没有返回值</li>
<li>三元运算符是表达式，具有返回值。</li>
</ol>
</li>
</ol>
<h4 id="2-void-运算符"><a href="#2-void-运算符" class="headerlink" title="2 void 运算符"></a>2 void 运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void expression</span><br></pre></td></tr></table></figure>

<ol>
<li>对给定的表达式进行求值，然后返回 <code>undefined</code></li>
<li>void 运算符通常只用于获取 <code>undefined</code> 的原始值，一般使用 <code>void(0)</code>（等同于<code>void 0</code>）</li>
<li>应用<ol>
<li><code>javascript: void(0);</code></li>
<li><code>() =&gt; void doSomething();</code></li>
</ol>
</li>
</ol>
<h4 id="3-逗号运算符"><a href="#3-逗号运算符" class="headerlink" title="3 逗号运算符"></a>3 逗号运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 从左到右依次计算每个表达式，并返回最后一个表达式的值</span><br><span class="line">expr1, expr2, expr3...</span><br><span class="line"></span><br><span class="line">&#x27;a&#x27;, &#x27;b&#x27; // &quot;b&quot;</span><br><span class="line">var x = 0;</span><br><span class="line">var y = (x++, 10);  // x=1 y=10</span><br></pre></td></tr></table></figure>

<h4 id="4-可选链"><a href="#4-可选链" class="headerlink" title="4 可选链"></a>4 可选链</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">school?.student?.name</span><br><span class="line"></span><br><span class="line">1 可选链是 ES11 中新增的一个特性</span><br><span class="line">2 主要作用是代码在进行 null 和 undefined 判断时更加清晰和简洁</span><br></pre></td></tr></table></figure>

<h2 id="3-4-语句"><a href="#3-4-语句" class="headerlink" title="3.4 语句"></a>3.4 语句</h2><h3 id="1-if-…-else"><a href="#1-if-…-else" class="headerlink" title="1 if … else"></a>1 if … else</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; else if (condition) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-switch-…-case"><a href="#2-switch-…-case" class="headerlink" title="2 switch … case"></a>2 switch … case</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// switch 内部采用严格相等</span><br><span class="line">switch (variable) &#123;</span><br><span class="line">    case value1:</span><br><span class="line">        statement</span><br><span class="line">        break;</span><br><span class="line">    case value2:</span><br><span class="line">        statement</span><br><span class="line">        break;</span><br><span class="line">    ...</span><br><span class="line">    default:</span><br><span class="line">        statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-for"><a href="#3-for" class="headerlink" title="3 for"></a>3 for</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (初始化条件【可以有多个】; 循环条件【boolean类型】; 循环迭代条件) &#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-while"><a href="#4-while" class="headerlink" title="4 while"></a>4 while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (condition) &#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-do-…-while"><a href="#5-do-…-while" class="headerlink" title="5 do … while"></a>5 do … while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">	statement</span><br><span class="line">&#125;</span><br><span class="line">while (condition)</span><br></pre></td></tr></table></figure>

<h3 id="6-label"><a href="#6-label" class="headerlink" title="6 label"></a>6 label</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">	statement</span><br><span class="line"></span><br><span class="line">1 &quot;label&quot;: 自定义名称</span><br><span class="line">2 相当于定位符，用于跳转到程序的任意位置，通常配合 `break`  和 `continue` 使用</span><br><span class="line">	break [label]</span><br><span class="line">	continue [label]</span><br></pre></td></tr></table></figure>

<h2 id="3-5-数据类型"><a href="#3-5-数据类型" class="headerlink" title="3.5 数据类型"></a>3.5 数据类型</h2><p><img src="D:/学无止境/00-教程/coderwhy/01-前端/03-JavaScript/img/数据类型.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1 获取数据类型的字符串形式</span><br><span class="line">typeof operand</span><br><span class="line"></span><br><span class="line">// 2 检测构造函数 prototype 属性指向的原型是否出现在某个实例对象的原型链上</span><br><span class="line">obj instanceof constructor</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>type</th>
<th>typeof Result</th>
</tr>
</thead>
<tbody><tr>
<td><code>number</code></td>
<td><code>&quot;number&quot;</code></td>
</tr>
<tr>
<td><code>bigint</code></td>
<td><code>&quot;bigint&quot;</code></td>
</tr>
<tr>
<td><code>string</code></td>
<td><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>&quot;boolean&quot;</code></td>
</tr>
<tr>
<td><code>undefined</code></td>
<td><code>&quot;undefined&quot;</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td><code>&quot;object&quot;</code></td>
</tr>
<tr>
<td><code>symbol</code></td>
<td><code>&quot;symbol&quot;</code></td>
</tr>
<tr>
<td><code>function object (implements [[Call]])</code></td>
<td><code>&quot;function&quot;</code></td>
</tr>
<tr>
<td><code>any other object</code></td>
<td><code>&quot;object&quot;</code></td>
</tr>
</tbody></table>
<ul>
<li><code>typeof null</code> 返回 <code>object</code> 是历史原因</li>
</ul>
<h2 id="3-6-异常"><a href="#3-6-异常" class="headerlink" title="3.6 异常"></a>3.6 异常</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h3><ol>
<li>通过 throw 关键字，抛出一个异常，可以让一个函数告知外界自己内部出现了错误</li>
<li>throw 可以抛出基本数据类型，但更常用的是抛出一个对象</li>
<li>JavaScript 提供了一个 Error 类</li>
<li>异常处理<ol>
<li>当调用一个函数且这个函数抛出了异常，若没有对这个异常进行处理，那么异常会往上抛，如果到了最顶层（全局）的代码中依然没有对这个异常的处理代码，就会报错并且终止程序的运行</li>
<li>使用 try…catch…finally 处理后，程序可以正常执行</li>
</ol>
</li>
</ol>
<h3 id="2-Error"><a href="#2-Error" class="headerlink" title="2 Error"></a>2 Error</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当代码运行时的发生错误，会创建新的Error 对象，并将其抛出</span><br><span class="line">new Error([message])</span><br></pre></td></tr></table></figure>

<h4 id="2-原型属性"><a href="#2-原型属性" class="headerlink" title="2 原型属性"></a>2 原型属性</h4><table>
<thead>
<tr>
<th>原型属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>message</td>
<td>错误信息，创建 Error 对象时传入的 message</td>
</tr>
<tr>
<td>name</td>
<td>Error的名称，通常和类的名称一致</td>
</tr>
<tr>
<td>stack</td>
<td>整个 Error 的错误信息，包括函数的调用栈，直接打印Error 对象时，打印的就是 stack</td>
</tr>
</tbody></table>
<h4 id="3-子类"><a href="#3-子类" class="headerlink" title="3 子类"></a>3 子类</h4><table>
<thead>
<tr>
<th>类型</th>
<th>错误原因</th>
</tr>
</thead>
<tbody><tr>
<td><code>EvalError</code></td>
<td>与 <code>eval()</code> 有关</td>
</tr>
<tr>
<td><code>RangeError</code></td>
<td>数值变量或参数超出其有效范围</td>
</tr>
<tr>
<td><code>ReferenceError</code></td>
<td>无效引用</td>
</tr>
<tr>
<td><code>SyntaxError</code></td>
<td>语法错误</td>
</tr>
<tr>
<td><code>TypeError</code></td>
<td>变量或参数不属于有效类型</td>
</tr>
<tr>
<td><code>URIError</code></td>
<td>给 <code>encodeURI()</code> 或  <code>decodeURl()</code> 传递的参数无效</td>
</tr>
</tbody></table>
<h1 id="四-工具"><a href="#四-工具" class="headerlink" title="四 工具"></a>四 工具</h1><ol>
<li>转译器 Transpiler：将现代 JS 代码翻译成所有浏览器都能看懂的代码<ul>
<li>Babel</li>
</ul>
</li>
<li>打包器 Bundler<ul>
<li>WebPack</li>
</ul>
</li>
<li>包管理工具<ol>
<li>npm</li>
<li>yarn</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/18/vim%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/18/vim%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">vim 操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-18 18:43:12 / 修改时间：19:39:56" itemprop="dateCreated datePublished" datetime="2022-01-18T18:43:12+08:00">2022-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/Soft/" itemprop="url" rel="index"><span itemprop="name">Soft</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/Soft/Vim/" itemprop="url" rel="index"><span itemprop="name">Vim</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><h2 id="1-1-命令格式"><a href="#1-1-命令格式" class="headerlink" title="1.1 命令格式"></a>1.1 命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[number][operator][number]motion</span><br><span class="line">	1 操作符：决定是什么操作</span><br><span class="line">	2 动作：决定被操作的文本（动作之前和之后光标之间的文本），注意 exclusive 和 inclusive</span><br><span class="line">	3 如果操作符和动作都有次数，则总次数为两者的乘积</span><br><span class="line">	4 当一个操作符命令被连续调用两次时，它会作用于当前行</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>d</code></td>
<td>删除（delete）</td>
</tr>
<tr>
<td><code>y</code></td>
<td>复制（yank 抽出到寄存器）</td>
</tr>
<tr>
<td><code>c</code></td>
<td>修改（change）</td>
</tr>
<tr>
<td><code>p</code></td>
<td>粘贴（put）</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>增加缩进</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>减少缩进</td>
</tr>
<tr>
<td><code>=</code></td>
<td>自动缩进</td>
</tr>
<tr>
<td><code>g~</code></td>
<td>反转大小写</td>
</tr>
<tr>
<td><code>gu</code></td>
<td>转换为小写</td>
</tr>
<tr>
<td><code>gU</code></td>
<td>转换为大写</td>
</tr>
</tbody></table>
<h2 id="1-2-单词-amp-字串"><a href="#1-2-单词-amp-字串" class="headerlink" title="1.2 单词 &amp; 字串"></a>1.2 单词 &amp; 字串</h2><table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>单词</td>
<td>以 <strong>非字母</strong> 分隔，由字母、数字、下划线或其他非空白字符的序列组成</td>
</tr>
<tr>
<td>字串</td>
<td>以 **空白字符 **分隔，由非空白字符序列组成</td>
</tr>
</tbody></table>
<h2 id="1-3-文本对象及范围"><a href="#1-3-文本对象及范围" class="headerlink" title="1.3 文本对象及范围"></a>1.3 文本对象及范围</h2><h3 id="1-文本对象"><a href="#1-文本对象" class="headerlink" title="1 文本对象"></a>1 文本对象</h3><table>
<thead>
<tr>
<th>文本对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>单词或字串</td>
<td><code>w/W</code>（word）</td>
</tr>
<tr>
<td>句子</td>
<td><code>s</code>（sentence）</td>
</tr>
<tr>
<td>段落</td>
<td><code>p</code>（paragraph）</td>
</tr>
<tr>
<td>引号</td>
<td><code>'"&#96;</code>（单 双 反）</td>
</tr>
<tr>
<td>括号</td>
<td><code>&lt;&gt;()[]&#123;&#125;</code></td>
</tr>
</tbody></table>
<h3 id="2-范围"><a href="#2-范围" class="headerlink" title="2 范围"></a>2 范围</h3><table>
<thead>
<tr>
<th>范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>i</code></td>
<td><code>inside</code></td>
</tr>
<tr>
<td><code>a</code></td>
<td><code>around</code></td>
</tr>
</tbody></table>
<h3 id="3-组合"><a href="#3-组合" class="headerlink" title="3 组合"></a>3 组合</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>iw</code></td>
<td>当前单词</td>
</tr>
<tr>
<td><code>aw</code></td>
<td>当前单词及其后空白</td>
</tr>
<tr>
<td><code>iW</code></td>
<td>当前字串</td>
</tr>
<tr>
<td><code>aW</code></td>
<td>当前字串及其后空白</td>
</tr>
<tr>
<td><code>is</code></td>
<td>当前句子</td>
</tr>
<tr>
<td><code>as</code></td>
<td>当前句子及其后空白</td>
</tr>
<tr>
<td><code>ip</code></td>
<td>当前段落</td>
</tr>
<tr>
<td><code>ap</code></td>
<td>当前段落及一个空行</td>
</tr>
<tr>
<td><code>i'"&#96;</code></td>
<td>引号内部</td>
</tr>
<tr>
<td><code>a'"&#96;</code></td>
<td>引号及其后空白</td>
</tr>
<tr>
<td><code>i&gt;)]&#125;</code></td>
<td>括号内部</td>
</tr>
<tr>
<td><code>a&gt;)]&#125;</code></td>
<td>括号及其内部</td>
</tr>
<tr>
<td><code>it</code></td>
<td>Html 或 Xml 一对标签内部</td>
</tr>
<tr>
<td><code>at</code></td>
<td>Html 或 Xml 一对标签及其内部</td>
</tr>
</tbody></table>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/18/vim%E6%93%8D%E4%BD%9C/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/18/vim%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/an3.JPG">
      <meta itemprop="name" content="安₃">
      <meta itemprop="description" content="我未成名君未嫁 可能俱是不如人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="琅嬛福地">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/18/vim%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">vim 概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-18 18:43:08 / 修改时间：18:49:36" itemprop="dateCreated datePublished" datetime="2022-01-18T18:43:08+08:00">2022-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/Soft/" itemprop="url" rel="index"><span itemprop="name">Soft</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/Soft/Vim/" itemprop="url" rel="index"><span itemprop="name">Vim</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一-模式"><a href="#一-模式" class="headerlink" title="一 模式"></a>一 模式</h1><table>
<thead>
<tr>
<th>模式</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>normal mode</td>
<td>普通模式（正常模式）</td>
<td>打开 Vim 后进入的默认模式</td>
</tr>
<tr>
<td>insert mode</td>
<td>插入模式</td>
<td>普通模式下按下 <code>i</code>、<code>I</code>、<code>a</code>、<code>A</code>、<code>o</code>、 <code>O</code> 等进入</td>
</tr>
<tr>
<td>insert-normal mode</td>
<td>插入-普通模式</td>
<td>在插入模式下使用 <code>ctrl-o</code> 进入，执行一次普通模式命令后返回插入模式</td>
</tr>
<tr>
<td>command-line mode</td>
<td>命令行模式</td>
<td>普通模式下按下 <code>:</code> 键进入，命令行模式中执行的命令又被称做 <strong>Ex</strong> 命令</td>
</tr>
<tr>
<td>Visual Mode</td>
<td>可视化模式</td>
<td>可视化模式下可以选择一块编辑区域，然后对选中的内容执行各种操作</td>
</tr>
<tr>
<td>Operator-Pending mode</td>
<td>操作符待决模式</td>
<td>命令通常为 <code>operator motion</code>，当只键入了操作符 <code>operator</code> 还没有键入动作 <code>motion</code> 时即为操作符待决模式</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1 进入可视化模式</span><br><span class="line">v		字符选择模式（character-wise visual mode），选中光标经过的所有字符</span><br><span class="line">V		行选择模式（line-wise visual mode），上下移动选中光标经过的所有行</span><br><span class="line">ctrl-v	块选择模式（block-wise visual mode），选中矩形框中的内容</span><br><span class="line">gv		重新选择上次选中内容（reselect the last selection）</span><br><span class="line"></span><br><span class="line"># 2 可视化模式下的操作</span><br><span class="line">o   	切换选区的活动端为对角，默认为右下角</span><br><span class="line">O   	切换选区的活动端为同一行的另一个角 </span><br><span class="line">u   	选中内容切换为小写         </span><br><span class="line">U   	选中内容切换为大写         </span><br><span class="line">-   	大小写切换             </span><br><span class="line">&gt;   	向右缩进              </span><br><span class="line">&lt;   	向左缩进              </span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/18/vim%E6%A6%82%E5%BF%B5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <div>
      
    </div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="安₃"
      src="/images/an3.JPG">
  <p class="site-author-name" itemprop="name">安₃</p>
  <div class="site-description" itemprop="description">我未成名君未嫁 可能俱是不如人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fas fa-star-and-crescent"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">安₃</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
